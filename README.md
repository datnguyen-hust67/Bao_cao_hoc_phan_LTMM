# B√ÅO C√ÅO QU√Å TR√åNH V√Ä T·ªîNG H·ª¢P KI·∫æN TH·ª®C H·ªåC PH·∫¶N L√ù THUY·∫æT M·∫¨T M√É

**Sinh vi√™n:** Nguy·ªÖn Th√†nh ƒê·∫°t
**MSSV:** 20223688 
**L·ªõp:** T√†i nƒÉng ƒêTVT K67 HUST 
**H·ªçc ph·∫ßn:** L√Ω thuy·∫øt m·∫≠t m√£  
**M·ª•c ƒë√≠ch:** B√°o c√°o qu√° tr√¨nh v√† t·ªïng h·ª£p ki·∫øn th·ª©c m√¥n L√Ω Thuy·∫øt M·∫≠t M√£ 

---

## üìã M·ª§C L·ª§C

1. [Ch∆∞∆°ng 1: ƒê√°nh gi√° qu√° tr√¨nh v√† c√°c ph·∫ßn ki·∫øn th·ª©c](#ch∆∞∆°ng-1-ƒë√°nh-gi√°-qu√°-tr√¨nh-v√†-c√°c-ph·∫ßn-ki·∫øn-th·ª©c)
2. [Ch∆∞∆°ng 2: C∆° S·ªü To√°n H·ªçc](#ch∆∞∆°ng-2-c∆°-s·ªü-to√°n-h·ªçc)
3. [Ch∆∞∆°ng 3: M√£ C·ªï ƒêi·ªÉn](#ch∆∞∆°ng-3-m√£-c·ªï-ƒëi·ªÉn)
4. [Ch∆∞∆°ng 4: M√£ Kh√≥a ƒê·ªëi X·ª©ng Hi·ªán ƒê·∫°i](#ch∆∞∆°ng-4-m√£-kh√≥a-ƒë·ªëi-x·ª©ng-hi·ªán-ƒë·∫°i)
5. [Ch∆∞∆°ng 5: M√£ DES](#ch∆∞∆°ng-5-des)
6. [Ch∆∞∆°ng 6: M√£ AES](#ch∆∞∆°ng-6-aes)
7. [Ch∆∞∆°ng 7: M√£ RSA](#ch∆∞∆°ng-8-m√£-rsa)
8. [Ch∆∞∆°ng 8: H√†m BƒÉm & Ch·ªØ K√Ω S·ªë](#ch∆∞∆°ng-8-h√†m-bƒÉm--ch·ªØ-k√Ω-s·ªë)
9. [K·∫øt lu·∫≠n](#k·∫øt-lu·∫≠n)

---

## Ch∆∞∆°ng 1: T·ª± ƒë√°nh gi√° qu√° tr√¨nh v√† c√°c ph·∫ßn ki·∫øn th·ª©c ƒë·∫°t ƒë∆∞·ª£c 

### 1.1 ƒê√°nh gi√° qu√° tr√¨nh

#### a) V·ªÅ chuy√™n c·∫ßn
- Trong 16 tu·∫ßn h·ªçc, em v·∫Øng 1 bu·ªïi h·ªçc 
- 15 tu·∫ßn c√≤n l·∫°i em ƒëi h·ªçc ƒë·∫ßy ƒë·ªß v√† t√≠ch c·ª±c trong gi·ªù h·ªçc, ho√†n th√†nh c√°c nhi·ªám v·ª• m√† th·∫ßy v√† anh giao tr√™n l·ªõp
- B√†i t·∫≠p v·ªÅ nh√† em n·ªôp ƒë·∫ßy ƒë·ªß, ƒë√∫ng h·∫°n ƒë∆∞·ª£c giao
#### b) V·ªÅ l√†m vi·ªác v·ªõi nh√≥m
- Nh√≥m em ƒë√£ c√πng nhau l√†m v√† tr√¨nh b√†y tr∆∞·ªõc l·ªõp 3 l·∫ßn, trong ƒë√≥
+ 1 l·∫ßn xung phong tr√¨nh b√†y v·ªÖ m√£ AES tr∆∞·ªõc l·ªõp
+ 1 l·∫ßn xung phong tr√¨nh b√†y v·ªÅ B√†i t·∫≠p l·ªõn gi·ªØa k·ª≥
+ 1 l·∫ßn b√°o c√°o v√†o cu·ªëi k·ª≥ 
- Trong c√°c bu·ªïi nh√≥m tr√¨nh b√†y, em ƒë·ªÅu c√≥ m·∫∑t ƒë·∫ßy ƒë·ªß v√† tr√¨nh b√†y c√πng c√°c b·∫°n
#### c) V·ªÅ nhi·ªám v·ª• b√†i t·∫≠p l·ªõn
- Nh√≥m em g·ªìm 3 b·∫°n ƒë√£ ph√°t tri·ªÉn ƒë∆∞·ª£c ·ª©ng d·ª•ng ChatNet gi√∫p tƒÉng c∆∞·ªùng b·∫£o m·∫≠t tin nh·∫Øn b·∫±ng 4 lo·∫°i m√£ h√≥a AES, DES, RSA, Caesar, h·ªó tr·ª£ g·ª≠i tin nh·∫Øn vƒÉn b·∫£n, h√¨nh ·∫£nh v√† t·∫≠p file, ƒë·ªìng th·ªùi nh√≥m c≈©ng ƒë√£ t√¨m hi·ªÉu v√† ph√°t tri·ªÉn t√≠nh nƒÉng m√£ h√≥a v√† g·ª≠i video, tuy nhi√™n do dung l∆∞·ª£ng video l·ªõn c√πng v·ªõi th·ªùi gian c√≥ h·∫°n, n√™n nh√≥m ch∆∞a ho√†n thi·ªán ƒë∆∞·ª£c t√≠nh nƒÉng n√†y. Trong th·ªùi gian t·ªõi, nh√≥m s·∫Ω ti·∫øp t·ª•c t√¨m t√≤i v√† ph√°t tri·ªÉn th√™m.
- Trong b√†i t·∫≠p l·ªõn, em l√†m ƒë∆∞·ª£c 40% tr√™n t·ªïng kh·ªëi l∆∞·ª£ng c√¥ng vi·ªác. ‚Äã

### 1.2 C√°c ki·∫øn th·ª©c t√≠ch l≈©y ƒë∆∞·ª£c

Trong 16 tu·∫ßn h·ªçc, d∆∞·ªõi s·ª± h∆∞·ªõng d·∫´n c·ªßa th·∫ßy PGS.TS ƒê·ªó Tr·ªçng Tu·∫•n v√† anh Ma Vi·ªát ƒê·ª©c, c√πng v·ªõi s·ª± t√¨m t√≤i v√† ƒë·ªçc th√™m t√†i li·ªáu, em ƒë√£ t√≠ch l≈©y ƒë∆∞·ª£c nh·ªØng ph·∫ßn ki·∫øn th·ª©c sau:

1. **Ch∆∞∆°ng 2** - C∆° s·ªü to√°n h·ªçc
   - GCD & Extended GCD (Bezout Lemma)
   - Modular Inverse & CRT
   - Factorization & Primality Testing
   
2. **Ch∆∞∆°ng 3** - M√£ c·ªï ƒëi·ªÉn
   - Caesar Cipher Brute Force
   - Vigen√®re Frequency Analysis (Kasiski, IC)
   - Affine Cipher
   
3. **Ch∆∞∆°ng 5** - M√£ DES
   - C·∫•u tr√∫c Feistel chi ti·∫øt
   - Key Schedule & Weak Keys
   - Meet-in-the-Middle Attack on 2DES
   
4. **Ch∆∞∆°ng 6** - M√£ AES
   - SubBytes, ShiftRows, MixColumns
   - Galois Field Arithmetic
   - So s√°nh DES vs AES
5. **Ch∆∞∆°ng 7** - M√£ kh√≥a b·∫•t ƒë·ªëi x·ª©ng  
   - L√Ω thuy·∫øt m√£ kh√≥a b·∫•t ƒë·ªëi x·ª©ng
   - H√†m trapdoor function
   - Hybrid Encryption 
6. **Ch∆∞∆°ng 8** - M√£ RSA
   - Sinh kh√≥a: Ch·ªçn p, q, t√≠nh e, d
   - V√≠ d·ª• t√≠nh to√°n chi ti·∫øt
   - C√°c t·∫•n c√¥ng: Brute Force, Factorization, Small Exponent
   - Meet-in-the-Middle Attack
   
7. **Ch∆∞∆°ng 9** - Hash & Signature
   - Merkle-Damg√•rd Construction
   - SHA-512 & HMAC chi ti·∫øt
   - T√≠nh ch·∫•t: Preimage, 2nd Preimage, Collision Resistance

### 1.3 Ph·∫°m vi v√† m·ª•c ti√™u c·ªßa vi·ªác t·ªïng h·ª£p

#### a) Ph·∫°m vi
| Ch∆∞∆°ng | Ch·ªß ƒë·ªÅ | Thu·∫≠t To√°n | 
|--------|--------|-----------|
| 2 | C∆° s·ªü to√°n h·ªçc | GCD, Extended GCD, CRT, RSA key | 
| 3 | M√£ c·ªï ƒëi·ªÉn | Caesar, Vigen√®re, Hill, Playfair | 
| 4 | Feistel & Boxes | P-box, S-box, DES structure |
| 5 | DES | DES encryption, Triple DES | 
| 6 | AES | SubBytes, ShiftRows, MixColumns | 
| 6.5 | Asymmetric theory | Trapdoor function, Public/Private key | 
| 7 | Public key | RSA, ElGamal, Knapsack | 
| 8 | Hash & Signature | SHA-512, HMAC, Digital Signature |

#### b) M·ª•c ti√™u 
‚úÖ**N·∫Øm ƒë∆∞·ª£c l√Ω Thuy·∫øt ƒë·ªÉ ·ª©ng d·ª•ng cho c√¥ng vi·ªác c≈©ng nh∆∞ thi:**
   - C√¥ng th·ª©c to√°n h·ªçc chi ti·∫øt
   - V√≠ d·ª• t√≠nh to√°n t·ª´ng b∆∞·ªõc
   - Ph√¢n t√≠ch b·∫£o m·∫≠t v√† t·∫•n c√¥ng
   - So s√°nh c√°c ph∆∞∆°ng ph√°p
   - ·ª®ng d·ª•ng th·ª±c t·∫ø c·ª• th·ªÉ

‚úÖ **N√¢ng cao k·ªπ nƒÉng code python v√† hi·ªÉu thu·∫≠t to√°n** (T·ª´ Scratch)
   - Kh√¥ng d√πng th∆∞ vi·ªán m√£ h√≥a
   - Gi√∫p hi·ªÉu r√µ c∆° ch·∫ø ho·∫°t ƒë·ªông
   - Th·ª±c hi·ªán c√°c thu·∫≠t to√°n chu·∫©n

‚úÖ **T·∫°o test cases ƒë·∫ßy ƒë·ªß ƒë·ªÉ hi·ªÉu h∆°n**
   - M·ªói thu·∫≠t to√°n c√≥ test case
   - Ki·ªÉm ch·ª©ng ƒë√∫ng/sai r√µ r√†ng
   - V√≠ d·ª• known plaintext

---

## CH∆Ø∆†NG 2: C∆† S·ªû TO√ÅN H·ªåC

### 2.1 S·ªë H·ªçc C√°c S·ªë Nguy√™n 

#### **A. ∆Ø·ªõc S·ªë Chung L·ªõn Nh·∫•t (GCD) - Thu·∫≠t To√°n Euclid**

**ƒê·ªãnh nghƒ©a:**
- GCD(a,b) l√† s·ªë nguy√™n d∆∞∆°ng l·ªõn nh·∫•t chia h·∫øt c·∫£ a v√† b
- K√Ω hi·ªáu: gcd(a,b) ho·∫∑c (a,b)

**Thu·∫≠t To√°n Euclid:**
```
GCD(a, b):
  if b = 0:
    return a
  else:
    return GCD(b, a mod b)
```

**V√≠ d·ª• t√≠nh to√°n:**
```
GCD(48, 18):
  48 = 18 √ó 2 + 12     ‚Üí GCD(18, 12)
  18 = 12 √ó 1 + 6      ‚Üí GCD(12, 6)
  12 = 6 √ó 2 + 0       ‚Üí GCD(6, 0)
  Return 6
```

**ƒê·ªô ph·ª©c t·∫°p:** O(log min(a,b))
- Tr∆∞·ªùng h·ª£p x·∫•u nh·∫•t: Fibonacci numbers
- GCD(F(n), F(n-1)) c·∫ßn n l·∫ßn l·∫∑p, F(n) ~ œÜ^n, n√™n O(log œÜ^n) = O(n)

**T√≠nh ch·∫•t quan tr·ªçng:**
1. gcd(a, b) = gcd(b, a) - Giao ho√°n
2. gcd(a, b) = gcd(a, b mod a) - T√≠nh ch·∫•t modulo
3. gcd(a, 0) = a - Tr∆∞·ªùng h·ª£p c∆° s·ªü
4. B·ªï ƒë·ªÅ Bezout: ‚àÉ x,y ‚àà ‚Ñ§: ax + by = gcd(a,b)

**H√†m th·ª±c hi·ªán:**
```python
      def gcd_euclidean(a, b):
        """
        Thu·∫≠t to√°n Euclid t√¨m ∆ØSCLN
        C√¥ng th·ª©c: gcd(a, b) = gcd(b, a mod b) cho ƒë·∫øn khi b = 0
        ƒê·ªô ph·ª©c t·∫°p: O(log(min(a,b)))
        
        V√≠ d·ª•: gcd(48, 18)
        48 = 18*2 + 12
        18 = 12*1 + 6
        12 = 6*2 + 0
        ‚Üí gcd = 6
        """
        while b != 0:
            a, b = b, a % b
        return a
```

---

#### **B. Extended GCD (Euclid M·ªü R·ªông)**

**M·ª•c ƒë√≠ch:** Kh√¥ng ch·ªâ t√¨m gcd(a,b), m√† c√≤n t√¨m x, y sao cho:
```
ax + by = gcd(a,b)
```

**Thu·∫≠t To√°n:**
```
Extended_GCD(a, b):
  if b = 0:
    return (a, 1, 0)  # gcd=a, x=1, y=0
  else:
    (g, x1, y1) = Extended_GCD(b, a mod b)
    x = y1
    y = x1 - (a // b) * y1
    return (g, x, y)
```

**V√≠ d·ª• chi ti·∫øt:**
```
Extended_GCD(48, 18):

B∆∞·ªõc 1: a=48, b=18, a mod b = 12
  G·ªçi Extended_GCD(18, 12)

B∆∞·ªõc 2: a=18, b=12, a mod b = 6
  G·ªçi Extended_GCD(12, 6)

B∆∞·ªõc 3: a=12, b=6, a mod b = 0
  G·ªçi Extended_GCD(6, 0)
  Return (6, 1, 0)  # 6*1 + 0*0 = 6 ‚úì

B∆∞·ªõc 3 quay l·∫°i: g=6, x1=1, y1=0
  x = 0
  y = 1 - (12//6)*0 = 1
  Return (6, 0, 1)  # 12*0 + 6*1 = 6 ‚úì

B∆∞·ªõc 2 quay l·∫°i: g=6, x1=0, y1=1
  x = 1
  y = 0 - (18//12)*1 = -1
  Return (6, 1, -1)  # 18*1 + 12*(-1) = 6 ‚úì

B∆∞·ªõc 1 quay l·∫°i: g=6, x1=1, y1=-1
  x = -1
  y = 1 - (48//18)*(-1) = 1 + 2 = 3
  Return (6, -1, 3)  # 48*(-1) + 18*3 = -48 + 54 = 6 ‚úì
```

**·ª®ng d·ª•ng quan tr·ªçng:**
1. **T√≠nh Modular Inverse**: T√¨m a‚Åª¬π mod m
   - N·∫øu gcd(a,m)=1, th√¨ Extended_GCD(a,m) = (1, x, y)
   - a*x + m*y = 1
   - a*x ‚â° 1 (mod m)
   - V·∫≠y a‚Åª¬π ‚â° x (mod m)

2. **Gi·∫£i ph∆∞∆°ng tr√¨nh Diophantine**: ax + by = c
   - N·∫øu c chia h·∫øt cho gcd(a,b), c√≥ v√¥ s·ªë nghi·ªám
   - Nghi·ªám t·ªïng qu√°t: x = x‚ÇÄ + (b/gcd)*t, y = y‚ÇÄ - (a/gcd)*t

**H√†m th·ª±c hi·ªán:**
```python
      def gcd_extended(a, b):
        """
        Thu·∫≠t to√°n Euclid m·ªü r·ªông
        T√¨m ∆ØSCLN v√† c√°c h·ªá s·ªë x, y sao cho: a*x + b*y = gcd(a,b)
        
        Tr·∫£ v·ªÅ: (gcd, x, y)
        
        ·ª®ng d·ª•ng:
        - T√¨m ph·∫ßn t·ª≠ ngh·ªãch ƒë·∫£o trong s·ªë h·ªçc m√¥ ƒëun
        - Gi·∫£i ph∆∞∆°ng tr√¨nh ƒë·ªìng d∆∞ tuy·∫øn t√≠nh
        """
        if b == 0:
            return a, 1, 0
        else:
            gcd, x1, y1 = MathematicsBasics.gcd_extended(b, a % b)
            x = y1
            y = x1 - (a // b) * y1
            return gcd, x, y
```

**K·∫øt qu·∫£ th·ª±c nghi·ªám:**
![K·∫øt qu·∫£ 1](/home/lenovo/cryptography_project/results/test1_gcd_extendedGCD.png)

---

#### **C. S·ªë Nguy√™n T·ªë v√† Ki·ªÉm Tra Nguy√™n T·ªë**

**ƒê·ªãnh nghƒ©a:**
- S·ªë nguy√™n t·ªë p: Ch·ªâ c√≥ ∆∞·ªõc s·ªë l√† 1 v√† p, p > 1
- V√≠ d·ª•: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, ...

**Ki·ªÉm tra nguy√™n t·ªë - Ph∆∞∆°ng ph√°p ƒë∆°n gi·∫£n:**
```
is_prime(n):
  if n < 2: return False
  if n = 2: return True
  if n % 2 = 0: return False
  for i = 3 to ‚àön step 2:
    if n % i = 0: return False
  return True
```

**ƒê·ªô ph·ª©c t·∫°p:** O(‚àön)

**V√≠ d·ª•:**
- is_prime(17): ‚àö17 ‚âà 4.1
  - Ki·ªÉm tra: 3 ‚Üí 17 % 3 = 2 (OK)
  - Kh√¥ng c·∫ßn ki·ªÉm tra 5 (> 4.1)
  - K·∫øt lu·∫≠n: 17 l√† nguy√™n t·ªë ‚úì

**Ki·ªÉm tra nguy√™n t·ªë n√¢ng cao:**
1. **Miller-Rabin** (X√°c su·∫•t): O(k log n) v·ªõi ƒë·ªô ch√≠nh x√°c 1 - 4^(-k)
2. **Lucas-Lehmer** (Mersenne primes): Chuy√™n d·ª•ng
3. **AKS Primality** (ƒêa th·ª©c): O(log^6 n) nh∆∞ng ch·∫≠m trong th·ª±c t·∫ø

**H√†m th·ª±c hi·ªán:**
```python
      def is_prime_simple(n):
        """
        Ki·ªÉm tra s·ªë nguy√™n t·ªë - ph∆∞∆°ng ph√°p ƒë∆°n gi·∫£n
        ƒê·ªô ph·ª©c t·∫°p: O(‚àön)
        
        M·ªôt s·ªë nguy√™n t·ªë l√† s·ªë t·ª± nhi√™n > 1 kh√¥ng c√≥ ∆∞·ªõc ngo√†i 1 v√† ch√≠nh n√≥
        """
        if n < 2:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False
        
        # Ki·ªÉm tra t·ª´ 3 ƒë·∫øn ‚àön
        for i in range(3, int(n**0.5) + 1, 2):
            if n % i == 0:
                return False
        return True
    
      def is_prime_fermat(n, k=5):
        """
        Ki·ªÉm tra s·ªë nguy√™n t·ªë - Fermat's Little Theorem
        N·∫øu p l√† s·ªë nguy√™n t·ªë th√¨: a^(p-1) ‚â° 1 (mod p) v·ªõi gcd(a, p) = 1
        
        ƒê·ªô ch√≠nh x√°c: cao nh∆∞ng kh√¥ng 100% (c√≥ s·ªë Carmichael)
        k: s·ªë l·∫ßn l·∫∑p (c√†ng cao c√†ng ch√≠nh x√°c)
        """
        import random
        
        if n < 2:
            return False
        if n == 2 or n == 3:
            return True
        if n % 2 == 0:
            return False
        
        for _ in range(k):
            a = random.randint(2, n - 2)
            if pow(a, n - 1, n) != 1:
                return False
        return True
```
**K·∫øt qu·∫£ th·ª±c nghi·ªám:**
![K·∫øt qu·∫£ 2](/home/lenovo/cryptography_project/results/test2_snt.png)
---

#### **D. Ph√¢n T√≠ch Th·ª´a S·ªë Nguy√™n T·ªë (Factorization)**

**B√†i to√°n:** Cho n, t√¨m n = p‚ÇÅ^a‚ÇÅ √ó p‚ÇÇ^a‚ÇÇ √ó ... √ó p‚Çñ^a‚Çñ

**Ph∆∞∆°ng ph√°p 1: Trial Division**
```
Factorization(n):
  factors = []
  for i = 2 to ‚àön:
    while n % i = 0:
      factors.append(i)
      n = n / i
  if n > 1:
    factors.append(n)
  return factors
```

**V√≠ d·ª•:**
```
Factorization(60):
  60 % 2 = 0 ‚Üí factors = [2], n = 30
  30 % 2 = 0 ‚Üí factors = [2,2], n = 15
  15 % 2 ‚â† 0 ‚Üí i = 3
  15 % 3 = 0 ‚Üí factors = [2,2,3], n = 5
  5 % 3 ‚â† 0, i > ‚àö5, n = 5 > 1
  factors = [2,2,3,5]
  Result: 60 = 2¬≤ √ó 3 √ó 5
```

**ƒê·ªô ph·ª©c t·∫°p:** O(‚àön)

**Ph∆∞∆°ng ph√°p 2: Pollard's Rho**
- ƒê·ªô ph·ª©c t·∫°p: O(n^(1/4))
- D√πng cho n l√† t√≠ch hai s·ªë nguy√™n t·ªë l·ªõn

**Kh√≥ khƒÉn:**
- Factorization l√† b√†i to√°n NP (trong s·ªë c√°c b√†i to√°n t√≠nh to√°n)
- Kh√¥ng c√≥ thu·∫≠t to√°n ƒëa th·ª©c nhanh ch√≥ng
- RSA d·ª±a v√†o ƒë·ªô kh√≥ n√†y!

**H√†m th·ª±c hi·ªán:**
```python
      def prime_factors(n):
        """
        Ph√¢n t√≠ch n th√†nh th·ª´a s·ªë nguy√™n t·ªë
        V√≠ d·ª•: 60 = 2^2 * 3 * 5
        ƒê·ªô ph·ª©c t·∫°p: O(‚àön)
        """
        factors = []
        d = 2
        
        while d * d <= n:
            while n % d == 0:
                factors.append(d)
                n //= d
            d += 1
        
        if n > 1:
            factors.append(n)
        
        return factors
```
**K·∫øt qu·∫£ th·ª±c nghi·ªám:**
![K·∫øt qu·∫£ 3](/home/lenovo/cryptography_project/results/test3_ptsnt.png)
---

### 2.2 S·ªë H·ªçc Module 

#### **A. Ph√©p T√≠nh Module**

**ƒê·ªãnh nghƒ©a:** a ‚â° b (mod m) n·∫øu m | (a - b)

**T√≠nh ch·∫•t:**
```
1. N·∫øu a ‚â° b (mod m) v√† c ‚â° d (mod m):
   - a + c ‚â° b + d (mod m)
   - a - c ‚â° b - d (mod m)
   - a √ó c ‚â° b √ó d (mod m)

2. N·∫øu a ‚â° b (mod m):
   - a^n ‚â° b^n (mod m) v·ªõi n ‚â• 0

3. N·∫øu d | m:
   - a ‚â° b (mod m) ‚áí a ‚â° b (mod d)
```

**V√≠ d·ª•:**
```
17 ‚â° 5 (mod 12)  (v√¨ 17 - 5 = 12, 12|12)
3 ‚â° 15 (mod 12)  (v√¨ 3 - 15 = -12, 12|-12)
17 ‚â° 5 (mod 12) ‚áí 17 ‚â° 5 (mod 4)  (4|12)
```

**H√†m th·ª±c hi·ªán:**
```python
      def modular_addition(a, b, m):
        """
        Ph√©p c·ªông m√¥ ƒëun: (a + b) mod m
        T√≠nh ch·∫•t: (a mod m + b mod m) mod m = (a + b) mod m
        """
        return (a + b) % m
    
      def modular_subtraction(a, b, m):
        """
        Ph√©p tr·ª´ m√¥ ƒëun: (a - b) mod m
        Ch√∫ √Ω: K·∫øt qu·∫£ lu√¥n kh√¥ng √¢m
        """
        return (a - b) % m
    
      def modular_multiplication(a, b, m):
        """
        Ph√©p nh√¢n m√¥ ƒëun: (a * b) mod m
        T√≠nh ch·∫•t: (a mod m) * (b mod m) mod m = (a * b) mod m
        """
        return (a * b) % m
    
      def modular_exponentiation(base, exp, mod):
        """
        T√≠nh base^exp mod mod hi·ªáu qu·∫£ (Square and Multiply)
        ƒê·ªô ph·ª©c t·∫°p: O(log(exp))
        
        Nguy√™n l√Ω: Bi·ªÉu di·ªÖn exp d∆∞·ªõi d·∫°ng nh·ªã ph√¢n
        V√≠ d·ª•: 2^10 mod 1000
        10 = 1010‚ÇÇ = 8 + 2
        2^10 = 2^8 * 2^2
        """
        result = 1
        base = base % mod
        
        while exp > 0:
            # N·∫øu exp l√† l·∫ª
            if exp % 2 == 1:
                result = (result * base) % mod
            
            # B√¨nh ph∆∞∆°ng c∆° s·ªë, chia ƒë√¥i exponent
            exp = exp >> 1  # Chia cho 2
            base = (base * base) % mod
        
        return result
```
**K·∫øt qu·∫£ th·ª±c nghi·ªám:**
![K·∫øt qu·∫£ 4](/home/lenovo/cryptography_project/results/test4.png)

---

#### **B. Modular Inverse (Ph·∫ßn T·ª≠ Ngh·ªãch ƒê·∫£o)**

**ƒê·ªãnh nghƒ©a:** a‚Åª¬π mod m l√† gi√° tr·ªã x sao cho:
```
a √ó x ‚â° 1 (mod m)
```

**ƒêi·ªÅu ki·ªán t·ªìn t·∫°i:**
```
gcd(a, m) = 1  (a v√† m nguy√™n t·ªë c√πng nhau)
```

**C√°ch t√≠nh b·∫±ng Extended GCD:**
```
Extended_GCD(a, m) = (1, x, y)
‚Üí a√óx + m√óy = 1
‚Üí a√óx ‚â° 1 (mod m)
‚Üí a‚Åª¬π ‚â° x (mod m)
```

**V√≠ d·ª•:**
```
T√¨m 7‚Åª¬π mod 26:
Extended_GCD(7, 26):
  26 = 7 √ó 3 + 5
  7 = 5 √ó 1 + 2
  5 = 2 √ó 2 + 1
  2 = 1 √ó 2 + 0

Quay l·∫°i:
  1 = 5 - 2 √ó 2
    = 5 - (7 - 5 √ó 1) √ó 2
    = 5 - 7 √ó 2 + 5 √ó 2
    = 5 √ó 3 - 7 √ó 2
    = (26 - 7 √ó 3) √ó 3 - 7 √ó 2
    = 26 √ó 3 - 7 √ó 9 - 7 √ó 2
    = 26 √ó 3 - 7 √ó 11
    = 7 √ó (-11) + 26 √ó 3

V·∫≠y: 7 √ó (-11) ‚â° 1 (mod 26)
     7 √ó 15 ‚â° 1 (mod 26)  (v√¨ -11 + 26 = 15)

Ki·ªÉm tra: 7 √ó 15 = 105 = 26 √ó 4 + 1 ‚úì
```

**H√†m th·ª±c hi·ªán:**
```python
      def modular_inverse(a, m):
        """
        T√¨m ngh·ªãch ƒë·∫£o m√¥ ƒëun c·ªßa a mod m
        T√¨m x sao cho: a*x ‚â° 1 (mod m)
        
        ƒêi·ªÅu ki·ªán: gcd(a, m) = 1
        S·ª≠ d·ª•ng Extended Euclidean Algorithm
        
        ·ª®ng d·ª•ng: Gi·∫£i ph∆∞∆°ng tr√¨nh ƒë·ªìng d∆∞ tuy·∫øn t√≠nh
        """
        gcd, x, _ = MathematicsBasics.gcd_extended(a, m)
        
        if gcd != 1:
            return None  # Ngh·ªãch ƒë·∫£o kh√¥ng t·ªìn t·∫°i
        
        return (x % m + m) % m
```
**K·∫øt qu·∫£ th·ª±c nghi·ªám:**
![K·∫øt qu·∫£ 5](/home/lenovo/cryptography_project/results/test5.png)
---

#### **C. ƒê·ªãnh L√Ω Ph·∫ßn D∆∞ Trung Hoa (Chinese Remainder Theorem - CRT)**

**Ph√°t bi·ªÉu:**
```
N·∫øu m‚ÇÅ, m‚ÇÇ, ..., m‚Çñ nguy√™n t·ªë c√πng nhau t·ª´ng ƒë√¥i m·ªôt:
h·ªá ph∆∞∆°ng tr√¨nh:
  x ‚â° a‚ÇÅ (mod m‚ÇÅ)
  x ‚â° a‚ÇÇ (mod m‚ÇÇ)
  ...
  x ‚â° a‚Çñ (mod m‚Çñ)

c√≥ nghi·ªám duy nh·∫•t modulo M = m‚ÇÅ √ó m‚ÇÇ √ó ... √ó m‚Çñ:
  x ‚â° Œ£·µ¢ a·µ¢ √ó M·µ¢ √ó (M·µ¢‚Åª¬π mod m·µ¢) (mod M)

trong ƒë√≥ M·µ¢ = M / m·µ¢
```

**V√≠ d·ª•:**
```
Gi·∫£i h·ªá:
  x ‚â° 2 (mod 3)
  x ‚â° 3 (mod 5)

M = 3 √ó 5 = 15
M‚ÇÅ = 15 / 3 = 5    ‚Üí 5‚Åª¬π mod 3 = 2  (v√¨ 5 ‚â° 2 (mod 3), 2√ó2=4‚â°1)
M‚ÇÇ = 15 / 5 = 3    ‚Üí 3‚Åª¬π mod 5 = 2  (v√¨ 3√ó2=6‚â°1)

x ‚â° 2√ó5√ó2 + 3√ó3√ó2 (mod 15)
  ‚â° 20 + 18 (mod 15)
  ‚â° 38 (mod 15)
  ‚â° 8 (mod 15)

Ki·ªÉm tra:
  8 ‚â° 2 (mod 3) ‚úì (8 = 2√ó3 + 2)
  8 ‚â° 3 (mod 5) ‚úì (8 = 1√ó5 + 3)
```

**·ª®ng d·ª•ng:**
1. **RSA Decryption**: T√≠nh M = C^d mod n nhanh h∆°n b·∫±ng CRT
2. **T·ªëi ∆∞u**: Thay v√¨ 1 ph√©p lu·ªπ th·ª´a mod n, d√πng 2 ph√©p mod p, q nh·ªè h∆°n

---

### 2.3 ƒê·ªìng d∆∞ tuy·∫øn t√≠nh

#### **A. Ph∆∞∆°ng tr√¨nh ƒë·ªìng d∆∞ tuy·∫øn t√≠nh**

**ƒê·ªãnh nghƒ©a:**
```
Gi·∫£i ph∆∞∆°ng tr√¨nh: ax ‚â° b (mod m)
T√¨m gi√° tr·ªã x sao cho ph∆∞∆°ng tr√¨nh th·ªèa m√£n
```

**ƒêi·ªÅu ki·ªán gi·∫£i:**
```
1. N·∫øu gcd(a, m) = 1:
   ‚Üí C√≥ ƒë√∫ng 1 nghi·ªám duy nh·∫•t
   ‚Üí x ‚â° a‚Åª¬π √ó b (mod m)

2. N·∫øu gcd(a, m) = d v√† d | b:
   ‚Üí C√≥ d nghi·ªám
   ‚Üí Nghi·ªám t·ªïng qu√°t: x = x‚ÇÄ + k(m/d), k = 0, 1, ..., d-1

3. N·∫øu gcd(a, m) = d v√† d ‚à§ b:
   ‚Üí V√¥ nghi·ªám (kh√¥ng t·ªìn t·∫°i x)
```

**V√≠ d·ª• chi ti·∫øt:**
```
V√≠ d·ª• 1: 3x ‚â° 9 (mod 12)
  gcd(3, 12) = 3, 9 chia h·∫øt cho 3 ‚úì
  Chia nh·ªè: x ‚â° 3 (mod 4)
  Nghi·ªám: x ‚àà {3, 7, 11} (3 nghi·ªám)

V√≠ d·ª• 2: 7x ‚â° 5 (mod 26)
  gcd(7, 26) = 1 ‚úì
  T√¨m 7‚Åª¬π mod 26 = 15 (v√¨ 7√ó15 = 105 = 4√ó26 + 1)
  x ‚â° 15 √ó 5 ‚â° 75 ‚â° 23 (mod 26)
  Ki·ªÉm tra: 7√ó23 = 161 = 6√ó26 + 5 ‚úì

V√≠ d·ª• 3: 2x ‚â° 3 (mod 8)
  gcd(2, 8) = 2, nh∆∞ng 3 kh√¥ng chia h·∫øt cho 2
  ‚Üí V√¥ nghi·ªám ‚úó
```

**H√†m th·ª±c hi·ªán:**
```python
def solve_linear_congruence(a, b, m):
    """
    Gi·∫£i ph∆∞∆°ng tr√¨nh ƒë·ªìng d∆∞: ax ‚â° b (mod m)
    
    ƒêi·ªÅu ki·ªán gi·∫£i:
    - N·∫øu gcd(a, m) = d v√† d | b: C√≥ d nghi·ªám
    - N·∫øu gcd(a, m) = 1: C√≥ ƒë√∫ng 1 nghi·ªám duy nh·∫•t
    - N·∫øu gcd(a, m) = d v√† d ‚à§ b: V√¥ nghi·ªám
    
    ·ª®ng d·ª•ng:
    - Affine cipher: ax ‚â° b (mod 26)
    - Hill cipher: Ax ‚â° b (mod 26)
    
    Tr·∫£ v·ªÅ: Danh s√°ch c√°c nghi·ªám ho·∫∑c []
    """
    d = gcd(a, m)
    
    # Ki·ªÉm tra ƒëi·ªÅu ki·ªán gi·∫£i
    if b % d != 0:
        return []  # V√¥ nghi·ªám
    
    # Chia nh·ªè b√†i to√°n
    a1 = a // d
    b1 = b // d
    m1 = m // d
    
    # T√¨m x‚ÇÄ t·ª´: a1*x0 ‚â° b1 (mod m1) v·ªõi gcd(a1, m1) = 1
    a1_inv = mod_inverse(a1, m1)
    x0 = (a1_inv * b1) % m1
    
    # T·∫•t c·∫£ nghi·ªám: x = x0 + k*(m/d), k = 0, 1, ..., d-1
    solutions = []
    for k in range(d):
        solutions.append(x0 + k * m1)
    
    return solutions
```
**K·∫øt qu·∫£ th·ª±c nghi·ªám:**
![K·∫øt qu·∫£ 6](/home/lenovo/cryptography_project/results/test6.png)

#### **B. ·ª®ng D·ª•ng: Affine Cipher**

**ƒê·ªãnh nghƒ©a:**
```
M√£ h√≥a: E(x) = (ax + b) mod 26
Gi·∫£i m√£: D(y) = a‚Åª¬π(y - b) mod 26
```

**ƒêi·ªÅu ki·ªán:**
- `gcd(a, 26) = 1` (ƒë·ªÉ a‚Åª¬π t·ªìn t·∫°i)
- `a ‚àà {1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25}` (12 gi√° tr·ªã h·ª£p l·ªá)
- `b ‚àà {0, 1, ..., 25}` (26 gi√° tr·ªã)
- **T·ªïng kh√≥a:** 12 √ó 26 = 312 kh√≥a

**V√≠ d·ª• chi ti·∫øt:**
```
M√£ h√≥a v·ªõi a=5, b=8:
E(x) = (5x + 8) mod 26

'H' ‚Üí x=7:
  E(7) = (5√ó7 + 8) mod 26 = 43 mod 26 = 17 ‚Üí 'R'

Gi·∫£i m√£ 'R' ‚Üí y=17:
  a‚Åª¬π = 5‚Åª¬π mod 26 = 21 (v√¨ 5√ó21 = 105 = 4√ó26 + 1)
  D(17) = 21√ó(17 - 8) mod 26 = 21√ó9 mod 26 = 189 mod 26 = 7 ‚Üí 'H' ‚úì
```

**H√†m th·ª±c hi·ªán:**
```python
def affine_cipher_encrypt(plaintext, a, b):
    """
    M√£ h√≥a Affine cipher
    E(x) = (ax + b) mod 26
    """
    ciphertext = ""
    for char in plaintext:
        if char.isalpha():
            x = ord(char.upper()) - ord('A')
            y = (a * x + b) % 26
            ciphertext += chr(y + ord('A'))
        else:
            ciphertext += char
    return ciphertext

def affine_cipher_decrypt(ciphertext, a, b):
    """
    Gi·∫£i m√£ Affine cipher
    D(y) = a‚Åª¬π(y - b) mod 26
    """
    a_inv = mod_inverse(a, 26)
    if a_inv == -1:
        return None
    
    plaintext = ""
    for char in ciphertext:
        if char.isalpha():
            y = ord(char.upper()) - ord('A')
            x = (a_inv * (y - b)) % 26
            plaintext += chr(x + ord('A'))
        else:
            plaintext += char
    return plaintext
```

### 2.4 Ma Tr·∫≠n (Matrix Operations)

#### **A. Ph√©p To√°n Ma Tr·∫≠n C∆° B·∫£n**

**1. Ph√©p C·ªông Ma Tr·∫≠n:**
```
C[i][j] = (A[i][j] + B[i][j]) mod m
```

**2. Ph√©p Tr·ª´ Ma Tr·∫≠n:**
```
C[i][j] = (A[i][j] - B[i][j]) mod m
```

**3. Ph√©p Nh√¢n Ma Tr·∫≠n:**
```
C[i][j] = Œ£‚Çñ (A[i][k] √ó B[k][j]) mod m
ƒê·ªô ph·ª©c t·∫°p: O(n¬≥)
```

**V√≠ d·ª• nh√¢n ma tr·∫≠n:**
```
A = [1 2]    B = [5 6]
    [3 4]        [7 8]

C[0][0] = 1√ó5 + 2√ó7 = 19
C[0][1] = 1√ó6 + 2√ó8 = 22
C[1][0] = 3√ó5 + 4√ó7 = 43
C[1][1] = 3√ó6 + 4√ó8 = 50

C = [19 22]
    [43 50]
```

**H√†m th·ª±c hi·ªán:**
```python
def matrix_multiply(A, B, mod=None):
    """
    Nh√¢n hai ma tr·∫≠n
    C[i][j] = Œ£(A[i][k] * B[k][j]) mod
    
    ƒê·ªô ph·ª©c t·∫°p: O(n¬≥) ph∆∞∆°ng ph√°p Naive
    
    ·ª®ng d·ª•ng: Hill cipher encryption
    """
    m, n = len(A), len(A[0])
    p, q = len(B), len(B[0])
    
    assert n == p, "Matrix dimensions incompatible for multiplication"
    
    C = [[0] * q for _ in range(m)]
    
    for i in range(m):
        for j in range(q):
            for k in range(n):
                C[i][j] += A[i][k] * B[k][j]
            if mod:
                C[i][j] %= mod
    
    return C
```

#### **B. ƒê·ªãnh Th·ª©c Ma Tr·∫≠n (Determinant)**

**Ma tr·∫≠n 2√ó2:**
```
     |a b|
det |c d| = ad - bc
```

**Ma tr·∫≠n 3√ó3 (Quy t·∫Øc Sarrus):**
```
     |a b c|
det |d e f| = a(ei - fh) - b(di - fg) + c(dh - eg)
     |g h i|
```

**V√≠ d·ª•:**
```
     |2 3|
det |4 5| = 2√ó5 - 3√ó4 = 10 - 12 = -2

Mod 26: -2 ‚â° 24 (mod 26)
```

**H√†m th·ª±c hi·ªán:**
```python
def matrix_determinant_2x2(A):
    """
    T√≠nh ƒë·ªãnh th·ª©c ma tr·∫≠n 2x2
    det(A) = a*d - b*c
    
    ·ª®ng d·ª•ng: Ki·ªÉm tra Hill cipher kh√≥a kh·∫£ ngh·ªãch
    """
    assert len(A) == 2 and len(A[0]) == 2, "Matrix must be 2x2"
    return A[0][0] * A[1][1] - A[0][1] * A[1][0]

def matrix_determinant_3x3(A):
    """
    T√≠nh ƒë·ªãnh th·ª©c ma tr·∫≠n 3x3
    det(A) = a(ei-fh) - b(di-fg) + c(dh-eg)
    """
    assert len(A) == 3 and len(A[0]) == 3, "Matrix must be 3x3"
    
    a, b, c = A[0]
    d, e, f = A[1]
    g, h, i = A[2]
    
    return a*(e*i - f*h) - b*(d*i - f*g) + c*(d*h - e*g)
```

#### **C. Ma Tr·∫≠n Ngh·ªãch ƒê·∫£o (Inverse Matrix)**

**ƒê·ªãnh nghƒ©a:**
```
A √ó A‚Åª¬π ‚â° I (mod m)
trong ƒë√≥ I l√† ma tr·∫≠n ƒë∆°n v·ªã
```

**ƒêi·ªÅu ki·ªán t·ªìn t·∫°i:**
```
gcd(det(A), m) = 1
T·ª©c l√†: det(A) ph·∫£i kh·∫£ ngh·ªãch mod m
```

**Ma tr·∫≠n 2√ó2:**
```
A = [a b]
    [c d]

A‚Åª¬π = 1/det(A) √ó [ d -b]
                  [-c  a]

Mod m:
A‚Åª¬π ‚â° (det(A))‚Åª¬π √ó [ d -b] (mod m)
                    [-c  a]
```

**V√≠ d·ª• chi ti·∫øt:**
```
A = [1 2]
    [3 5]

det(A) = 1√ó5 - 2√ó3 = -1 ‚â° 25 (mod 26)
det(A)‚Åª¬π = 25‚Åª¬π mod 26 = 25 (v√¨ 25√ó25 = 625 = 24√ó26 + 1)

A‚Åª¬π ‚â° 25 √ó [ 5 -2] ‚â° [ 125  -50] ‚â° [21 24] (mod 26)
           [-3  1]    [-75   25]    [3  25]

Ki·ªÉm tra: A √ó A‚Åª¬π ‚â° I (mod 26) ‚úì
```

**H√†m th·ª±c hi·ªán:**
```python
def matrix_inverse_2x2(A, mod):
    """
    T√≠nh ma tr·∫≠n ngh·ªãch ƒë·∫£o 2x2 (mod m)
    
    C√¥ng th·ª©c:
    A‚Åª¬π = 1/det(A) √ó [d -b; -c a]
    
    ƒêi·ªÅu ki·ªán: gcd(det(A), m) = 1
    """
    det = (A[0][0] * A[1][1] - A[0][1] * A[1][0]) % mod
    det_inv = mod_inverse(det, mod)
    
    if det_inv == -1:
        return None  # Kh√¥ng c√≥ ma tr·∫≠n ngh·ªãch ƒë·∫£o
    
    # C√¥ng th·ª©c: det_inv √ó [d -b; -c a]
    return [
        [(det_inv * A[1][1]) % mod, (-det_inv * A[0][1]) % mod],
        [(-det_inv * A[1][0]) % mod, (det_inv * A[0][0]) % mod]
    ]
```
**K·∫øt qu·∫£ th·ª±c nghi·ªám:**
![K·∫øt qu·∫£ 7-8](/home/lenovo/cryptography_project/results/test7_8.png)

#### **D. ·ª®ng D·ª•ng: Hill Cipher**

**ƒê·ªãnh nghƒ©a:**
```
M√£ h√≥a: C ‚â° K √ó P (mod 26)
Gi·∫£i m√£: P ‚â° K‚Åª¬π √ó C (mod 26)

trong ƒë√≥:
- K: ma tr·∫≠n kh√≥a (2√ó2 ho·∫∑c 3√ó3)
- P: ma tr·∫≠n plaintext
- C: ma tr·∫≠n ciphertext
```

**V√≠ d·ª• 2√ó2:**
```
Kh√≥a K = [1 2]
         [3 5]

M√£ h√≥a "HELP":
HE ‚Üí [7, 4]·µÄ
LP ‚Üí [11, 15]·µÄ

C ‚â° K √ó P (mod 26):
C ‚â° [1 2] √ó [7]  ‚â° [7+8]   ‚â° [15] (mod 26) ‚Üí 'P'
    [3 5]   [4]    [21+20]   [15]           ‚Üí 'P'

So ciphertext: "PPXX" (sau khi m√£ h√≥a h·∫øt)
```

**H√†m th·ª±c hi·ªán:**
```python
def hill_cipher_encrypt(plaintext, key, block_size=2):
    """
    M√£ h√≥a Hill cipher
    C ‚â° K √ó P (mod 26)
    
    ƒêi·ªÅu ki·ªán: gcd(det(K), 26) = 1
    """
    # Chu·∫©n b·ªã plaintext (padding n·∫øu c·∫ßn)
    plaintext = plaintext.upper().replace(" ", "")
    if len(plaintext) % block_size != 0:
        plaintext += "X" * (block_size - len(plaintext) % block_size)
    
    ciphertext = ""
    
    # M√£ h√≥a t·ª´ng block
    for i in range(0, len(plaintext), block_size):
        block = plaintext[i:i+block_size]
        # Chuy·ªÉn sang ma tr·∫≠n
        p = [[ord(c) - ord('A')] for c in block]
        # Nh√¢n v·ªõi kh√≥a
        c = matrix_multiply(key, p, mod=26)
        # Chuy·ªÉn sang text
        for j in range(block_size):
            ciphertext += chr(c[j][0] + ord('A'))
    
    return ciphertext

def hill_cipher_decrypt(ciphertext, key, key_inv, block_size=2):
    """
    Gi·∫£i m√£ Hill cipher
    P ‚â° K‚Åª¬π √ó C (mod 26)
    """
    ciphertext = ciphertext.upper()
    plaintext = ""
    
    # Gi·∫£i m√£ t·ª´ng block
    for i in range(0, len(ciphertext), block_size):
        block = ciphertext[i:i+block_size]
        # Chuy·ªÉn sang ma tr·∫≠n
        c = [[ord(char) - ord('A')] for char in block]
        # Nh√¢n v·ªõi ma tr·∫≠n ngh·ªãch ƒë·∫£o
        p = matrix_multiply(key_inv, c, mod=26)
        # Chuy·ªÉn sang text
        for j in range(block_size):
            plaintext += chr(p[j][0] + ord('A'))
    
    return plaintext
```

---

## CH∆Ø∆†NG 3: M√É C·ªî ƒêI·ªÇN (CLASSICAL CIPHERS)

### Gi·ªõi thi·ªáu

M√£ c·ªï ƒëi·ªÉn l√† c√°c h·ªá m√£ ho·∫°t ƒë·ªông tr√™n k√Ω t·ª± (character-level), ƒë∆∞·ª£c s√°ng t·∫°o tr∆∞·ªõc th·ªùi m√°y t√≠nh. 
H·∫ßu h·∫øt ƒë·ªÅu ƒë√£ b·ªã ph√° v·ª° nh∆∞ng c√≥ gi√° tr·ªã gi√°o d·ª•c cao ƒë·ªÉ hi·ªÉu r√µ c∆° ch·∫ø m√£ h√≥a.

---

### 3.1 Caesar Cipher - Brute Force Attack

####  **A. L√Ω Thuy·∫øt**

**ƒê·ªãnh nghƒ©a:**
```
M√£ h√≥a: E(x) = (x + k) mod 26
Gi·∫£i m√£: D(y) = (y - k) mod 26
```

**ƒê·∫∑c ƒëi·ªÉm:**
- Caesar d·ªãch m·ªói k√Ω t·ª± ƒëi k v·ªã tr√≠ c·ªë ƒë·ªãnh
- Ch·ªâ c√≥ 26 kh√≥a c√≥ th·ªÉ (k = 0 ƒë·∫øn 25)
- k = 0: kh√¥ng m√£ h√≥a
- k = 13: ROT13 (th∆∞·ªùng d√πng trong th·ª±c t·∫ø)
- R·∫•t d·ªÖ b·ªã brute force

**V√≠ d·ª•:**
```
Plaintext: HELLO
k = 3:
H ‚Üí (7 + 3) mod 26 = 10 ‚Üí K
E ‚Üí (4 + 3) mod 26 = 7 ‚Üí H
L ‚Üí (11 + 3) mod 26 = 14 ‚Üí O
L ‚Üí (11 + 3) mod 26 = 14 ‚Üí O
O ‚Üí (14 + 3) mod 26 = 17 ‚Üí R

Ciphertext: KHOOR ‚úì
```

####  **B. Brute Force Attack**

**Ph∆∞∆°ng ph√°p:**
```
for k = 0 to 25:
  M' = Decrypt(C, k)
  if M' l√† text ti·∫øng Anh:
    return k
```

**Ph∆∞∆°ng ph√°p nh·∫≠n di·ªán text:**

1. **Chi-squared test:** Ki·ªÉm tra ph√¢n ph·ªëi t·∫ßn s·ªë
   ```
   œá¬≤ = Œ£ (observed - expected)¬≤ / expected
   
   N·∫øu œá¬≤ nh·ªè ‚Üí C√≥ th·ªÉ l√† text h·ª£p l·ªá
   ```

2. **Entropy:** Ng√¥n ng·ªØ t·ª± nhi√™n c√≥ entropy < random
   ```
   H = -Œ£ p·µ¢ log‚ÇÇ(p·µ¢)
   
   Ti·∫øng Anh: ~4.7 bits/k√Ω t·ª±
   Random: ~5.0 bits/k√Ω t·ª±
   ```

3. **T·ª´ ƒëi·ªÉn:** Ki·ªÉm tra xem c√≥ t·ª´ h·ª£p l·ªá kh√¥ng
   ```
   N·∫øu decrypt_text ch·ª©a nhi·ªÅu t·ª´ h·ª£p l·ªá ‚Üí kh√≥a ƒë√∫ng
   ```

####  **C. V√≠ D·ª• Chi Ti·∫øt**

```
Ciphertext: "KHOOR ZRUOG"

Brute force th·ª≠ k = 0 ƒë·∫øn 25:
k = 0: KHOOR ZRUOG (kh√¥ng h·ª£p l·ªá)
k = 1: JGNNQ YQTNF (kh√¥ng h·ª£p l·ªá)
k = 2: IFMMP XPUMC (kh√¥ng h·ª£p l·ªá)
k = 3: HELLO WORLD ‚úì (t·ª´ ƒëi·ªÉn: HELLO, WORLD h·ª£p l·ªá!)

T√¨m th·∫•y: KHOOR ZRUOG ‚Üí HELLO WORLD (k = 3)
```

####  **D. H√†m Th·ª±c Hi·ªán**

```python
def caesar_encrypt(plaintext, k):
    """M√£ h√≥a Caesar"""
    ciphertext = ""
    for char in plaintext:
        if char.isalpha():
            base = ord('A') if char.isupper() else ord('a')
            shifted = (ord(char) - base + k) % 26
            ciphertext += chr(shifted + base)
        else:
            ciphertext += char
    return ciphertext

def caesar_decrypt(ciphertext, k):
    """Gi·∫£i m√£ Caesar"""
    return caesar_encrypt(ciphertext, -k)

def caesar_brute_force(ciphertext, dictionary=None):
    """
    T·∫•n c√¥ng brute force Caesar
    Th·ª≠ t·∫•t c·∫£ 26 kh√≥a v√† ki·ªÉm tra h·ª£p l·ªá
    """
    for k in range(26):
        decrypted = caesar_decrypt(ciphertext, k)
        
        # Ph∆∞∆°ng ph√°p 1: Ki·ªÉm tra t·ª´ ƒëi·ªÉn
        if dictionary and all(word in dictionary for word in decrypted.split()):
            return k, decrypted
        
        # Ph∆∞∆°ng ph√°p 2: Chi-squared test
        chi_squared = calculate_chi_squared(decrypted)
        if chi_squared < THRESHOLD:
            return k, decrypted
    
    return None, None
```

**ƒê·ªô ph·ª©c t·∫°p:** O(26 √ó n) = O(n) tuy·∫øn t√≠nh ‚Üí R·∫•t y·∫øu! ‚úó

####  **E. K·∫øt Qu·∫£ Ki·ªÉm Th·ª≠**

```
Caesar Cipher Brute Force:
Ciphertext: KHOOR ZRUOG
Trying k = 0: KHOOR ZRUOG (chi_squared = 2845.3) ‚úó
Trying k = 1: JGNNQ YQTNF (chi_squared = 3012.1) ‚úó
...
Trying k = 3: HELLO WORLD (chi_squared = 12.5) ‚úì

Result: k = 3, Plaintext = HELLO WORLD ‚úì
```

**K·∫øt qu·∫£ th·ª±c nghi·ªám:**
![K·∫øt qu·∫£ 9](/home/lenovo/cryptography_project/results/test3.1.png)

### 3.2 M√£ Thay Th·∫ø (Substitution Cipher)

####  **A. L√Ω Thuy·∫øt**

**ƒê·ªãnh nghƒ©a:**
```
T·∫°o b·∫£ng thay th·∫ø: A ‚Üí Q, B ‚Üí P, C ‚Üí M, ...
M√£ h√≥a: Thay th·∫ø t·ª´ng k√Ω t·ª± theo b·∫£ng
```

**ƒê·∫∑c ƒëi·ªÉm:**
- B·∫£ng thay th·∫ø c√≥ 26! ‚âà 4 √ó 10¬≤‚Å∂ kh√≥a c√≥ th·ªÉ
- Che gi·∫•u t·∫ßn s·ªë k√Ω t·ª± t·ªët h∆°n Caesar
- Nh∆∞ng v·∫´n c√≥ th·ªÉ b·ªã t·∫•n c√¥ng frequency analysis

####  **B. V√≠ D·ª•**

```
B·∫£ng thay th·∫ø:
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
Q W E R T Y U I O P A S D F G H J K L Z X C V B N M

Plaintext: HELLO
H ‚Üí I, E ‚Üí T, L ‚Üí D, L ‚Üí D, O ‚Üí O
Ciphertext: ITDDO
```

####  **C. H√†m Th·ª±c Hi·ªán**

```python
def substitution_encrypt(plaintext, key):
    """M√£ h√≥a thay th·∫ø"""
    alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    ciphertext = ""
    for char in plaintext:
        if char.isalpha():
            idx = ord(char.upper()) - ord('A')
            ciphertext += key[idx]
        else:
            ciphertext += char
    return ciphertext

def substitution_decrypt(ciphertext, key):
    """Gi·∫£i m√£ thay th·∫ø"""
    alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    plaintext = ""
    for char in ciphertext:
        if char.isalpha():
            idx = key.index(char)
            plaintext += alphabet[idx]
        else:
            plaintext += char
    return plaintext
```

**ƒê·ªô ph·ª©c t·∫°p t·∫•n c√¥ng:** O(26! √ó n) ‚âà kh√¥ng kh·∫£ thi b·∫±ng brute force ‚úó

**K·∫øt qu·∫£ th·ª±c nghi·ªám:**
![K·∫øt qu·∫£ 10](/home/lenovo/cryptography_project/results/test3.2.png)

### 3.3 Vigen√®re Cipher - Polyalphabetic Cipher

####  **A. L√Ω Thuy·∫øt**

**ƒê·ªãnh nghƒ©a:**
```
V·ªõi kh√≥a K = k‚ÇÅk‚ÇÇ...k‚Çò (ƒë·ªô d√†i m):
E(p·µ¢) = (p·µ¢ + k_{(i mod m)}) mod 26
D(c·µ¢) = (c·µ¢ - k_{(i mod m)}) mod 26
```

**ƒê·∫∑c ƒëi·ªÉm:**
- M·ªói v·ªã tr√≠ c√≥ shift kh√°c nhau
- Che gi·∫•u t·∫ßn s·ªë k√Ω t·ª± ƒë∆°n l·∫ª (polyalphabetic)
- Caesar l√† tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát khi ƒë·ªô d√†i kh√≥a = 1
- ƒê∆∞·ª£c coi l√† "unbreakable" trong 300 nƒÉm!

####  **B. V√≠ D·ª• Chi Ti·∫øt**

```
Plaintext: HELLO WORLD
Key: KEY (l·∫∑p l·∫°i: K E Y K E Y K E Y K)

M√£ h√≥a:
H + K(10) ‚Üí R
E + E(4)  ‚Üí I
L + Y(24) ‚Üí J
L + K(10) ‚Üí V
O + E(4)  ‚Üí S

(T∆∞∆°ng t·ª± cho WORLD)

Ciphertext: RIJVS UYVJN

Nh·∫≠n x√©t: HELLO ‚Üí RIJVS nh∆∞ng WORLD ‚Üí UYVJN
          C√πng t·ª´ nh∆∞ng kh√°c ciphertext!
```

####  **C. T·∫•n C√¥ng 1: Kasiski Examination**

**Nguy√™n l√Ω:**
- N·∫øu c·ª© m·ªói m k√Ω t·ª± l·∫∑p l·∫°i th√¨ c√≥ c∆° h·ªôi cao l√† c√πng shift
- Kho·∫£ng c√°ch gi·ªØa chu·ªói l·∫∑p l·∫°i th∆∞·ªùng l√† b·ªôi s·ªë c·ªßa m

**Ph∆∞∆°ng ph√°p:**
```
1. T√¨m c√°c chu·ªói 2-3 k√Ω t·ª± l·∫∑p l·∫°i
2. T√≠nh kho·∫£ng c√°ch gi·ªØa ch√∫ng
3. T√≠nh GCD(kho·∫£ng c√°ch) ‚Üí ƒê·ªô d√†i kh√≥a m
```

**V√≠ d·ª•:**
```
Ciphertext: "THE QUICK BROWN FOX THE LAZY DOG"
                          ‚Üì
           "THE" l·∫∑p l·∫°i ·ªü v·ªã tr√≠ 0 v√† 24
           Kho·∫£ng c√°ch = 24
           
Th·ª≠ m = 1,2,3,4,6,8,12,24
Nh·ªØng m n√†o l√† ∆∞·ªõc c·ªßa 24: t·∫•t c·∫£!
```

####  *D. T·∫•n C√¥ng 2: Index of Coincidence**

**ƒê·ªãnh nghƒ©a:**
```
IC = Œ£·µ¢ n·µ¢(n·µ¢-1) / (N(N-1))

Trong ƒë√≥:
- n·µ¢ = s·ªë l·∫ßn k√Ω t·ª± i xu·∫•t hi·ªán
- N = t·ªïng s·ªë k√Ω t·ª±
```

**Gi√° tr·ªã t√≠p:**
```
Ti·∫øng Anh: IC ‚âà 0.065
Random: IC ‚âà 0.038
```

**Ph∆∞∆°ng ph√°p:**
```
1. Th·ª≠ m = 1, 2, 3, ..., 20
2. V·ªõi m·ªói m, t√°ch th√†nh m "c·ªôt"
3. T√≠nh IC c·ªßa m·ªói c·ªôt
4. N·∫øu IC ‚âà 0.065 ‚Üí m ƒë√∫ng
```

####  **E. H√†m Th·ª±c Hi·ªán**

```python
def vigenere_encrypt(plaintext, key):
    """M√£ h√≥a Vigen√®re"""
    ciphertext = ""
    key_upper = key.upper()
    key_idx = 0
    
    for char in plaintext:
        if char.isalpha():
            shift = ord(key_upper[key_idx % len(key)]) - ord('A')
            if char.isupper():
                encrypted = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))
            else:
                encrypted = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))
            ciphertext += encrypted
            key_idx += 1
        else:
            ciphertext += char
    
    return ciphertext

def vigenere_decrypt(ciphertext, key):
    """Gi·∫£i m√£ Vigen√®re"""
    plaintext = ""
    key_upper = key.upper()
    key_idx = 0
    
    for char in ciphertext:
        if char.isalpha():
            shift = ord(key_upper[key_idx % len(key)]) - ord('A')
            if char.isupper():
                decrypted = chr((ord(char) - ord('A') - shift) % 26 + ord('A'))
            else:
                decrypted = chr((ord(char) - ord('a') - shift) % 26 + ord('a'))
            plaintext += decrypted
            key_idx += 1
        else:
            plaintext += char
    
    return plaintext

def kasiski_examination(ciphertext):
    """
    Kasiski examination ƒë·ªÉ t√¨m ƒë·ªô d√†i kh√≥a
    T√¨m trigrams l·∫∑p l·∫°i v√† t√≠nh GCD
    """
    trigrams = {}
    for i in range(len(ciphertext) - 2):
        tri = ciphertext[i:i+3]
        if tri not in trigrams:
            trigrams[tri] = []
        trigrams[tri].append(i)
    
    distances = []
    for tri, positions in trigrams.items():
        if len(positions) > 1:
            for i in range(len(positions) - 1):
                distances.append(positions[i+1] - positions[i])
    
    if not distances:
        return None
    
    from math import gcd
    from functools import reduce
    key_length = reduce(gcd, distances)
    
    return key_length if key_length > 1 else None

def index_of_coincidence(text):
    """T√≠nh Index of Coincidence"""
    freq = {}
    for char in text.upper():
        if char.isalpha():
            freq[char] = freq.get(char, 0) + 1
    
    n = sum(freq.values())
    if n < 2:
        return 0
    
    ic = sum(count * (count - 1) for count in freq.values()) / (n * (n - 1))
    return ic
```

**ƒê·ªô ph·ª©c t·∫°p t·∫•n c√¥ng:** O(n¬≤) n·∫øu bi·∫øt ƒë·ªô d√†i kh√≥a

**K·∫øt qu·∫£ th·ª±c nghi·ªám:**
![K·∫øt qu·∫£ 11](/home/lenovo/cryptography_project/results/test3.3.png)

### 3.4 Hill Cipher - Matrix Cipher

####  **A. L√Ω Thuy·∫øt**

**ƒê·ªãnh nghƒ©a:**
```
M√£ h√≥a: C ‚â° K √ó P (mod 26)
Gi·∫£i m√£: P ‚â° K‚Åª¬π √ó C (mod 26)

Trong ƒë√≥:
- K: ma tr·∫≠n kh√≥a 2√ó2 ho·∫∑c 3√ó3
- P: vector plaintext
- C: vector ciphertext
```

**ƒêi·ªÅu ki·ªán:**
```
gcd(det(K), 26) = 1
(ma tr·∫≠n ph·∫£i kh·∫£ ngh·ªãch mod 26)
```

####  **B. V√≠ D·ª• 2√ó2**

```
Kh√≥a: K = [1 2]
          [3 5]

det(K) = 1√ó5 - 2√ó3 = -1 ‚â° 25 (mod 26)
gcd(25, 26) = 1 ‚úì (kh·∫£ ngh·ªãch)

M√£ h√≥a "HE":
H = 7, E = 4
P = [7, 4]·µÄ

C ‚â° [1 2] √ó [7] ‚â° [1√ó7 + 2√ó4] ‚â° [15] (mod 26)
    [3 5]   [4]   [3√ó7 + 5√ó4]   [41]

C ‚â° [15, 15] (mod 26) ‚Üí "PP"

Gi·∫£i m√£ "PP":
K‚Åª¬π ‚â° (det‚Åª¬π) √ó [5 -2] ‚â° 25 √ó [5 -2] ‚â° [125 -50] ‚â° [21 24] (mod 26)
                [-3 1]        [-3 1]     [-75  25]    [3  25]

P ‚â° [21 24] √ó [15] ‚â° [21√ó15 + 24√ó15] ‚â° [525] ‚â° [7] (mod 26) ‚Üí "HE" ‚úì
    [3  25]   [15]   [3√ó15 + 25√ó15]    [420]   [4]
```

####  **C. H√†m Th·ª±c Hi·ªán**

```python
def hill_cipher_encrypt_2x2(plaintext, key_matrix):
    """
    M√£ h√≥a Hill cipher 2x2
    key_matrix: [[a, b], [c, d]]
    """
    P_vec = [ord(c) - ord('A') for c in plaintext if c.isalpha()]
    
    ciphertext = ""
    for i in range(0, len(P_vec) - 1, 2):
        P = [[P_vec[i]], [P_vec[i+1]]]
        C = matrix_multiply(key_matrix, P, 26)
        ciphertext += chr(C[0][0] + ord('A')) + chr(C[1][0] + ord('A'))
    
    return ciphertext

def hill_cipher_decrypt_2x2(ciphertext, key_matrix_inv):
    """Gi·∫£i m√£ Hill cipher 2x2"""
    C_vec = [ord(c) - ord('A') for c in ciphertext if c.isalpha()]
    
    plaintext = ""
    for i in range(0, len(C_vec) - 1, 2):
        C = [[C_vec[i]], [C_vec[i+1]]]
        P = matrix_multiply(key_matrix_inv, C, 26)
        plaintext += chr(P[0][0] + ord('A')) + chr(P[1][0] + ord('A'))
    
    return plaintext
```

**ƒê·ªô ph·ª©c t·∫°p:** O(n √ó k¬≥) v·ªõi k l√† k√≠ch th∆∞·ªõc ma tr·∫≠n

**K·∫øt qu·∫£ th·ª±c nghi·ªám:**
![K·∫øt qu·∫£ 12](/home/lenovo/cryptography_project/results/test3.4.png)

### 3.5 Playfair Cipher

####  **A. L√Ω Thuy·∫øt**

**ƒê·∫∑c ƒëi·ªÉm:**
- M√£ h√≥a t·ª´ng c·∫∑p k√Ω t·ª± (digraph)
- D√πng ma tr·∫≠n 5√ó5 (25 k√Ω t·ª±, J = I)
- Quy t·∫Øc: 
  - C√πng h√†ng: d·ªãch sang ph·∫£i (circular)
  - C√πng c·ªôt: d·ªãch xu·ªëng (circular)
  - H√¨nh ch·ªØ nh·∫≠t: swap 2 g√≥c ngang

####  **B. V√≠ D·ª•**

```
Key: PLAYFAIR
B·∫£ng:
P L A Y F
I R E X M
B C D G H
K N O S T
U V W Z Q

M√£ h√≥a "HELLO":
HE: H(2,3), E(1,2) - h√¨nh ch·ªØ nh·∫≠t ‚Üí X(1,3), G(2,2) = XG
LL: L(0,1), L(0,1) - c√πng k√Ω t·ª± ‚Üí th√™m X ‚Üí LL = LX LL
O: cu·ªëi ‚Üí X

Ciphertext: XGLXLX
```

####  **C. H√†m Th·ª±c Hi·ªán**

```python
def playfair_create_key_matrix(key):
    """T·∫°o b·∫£ng Playfair 5x5"""
    key = key.upper().replace('J', 'I')
    used = set()
    matrix = []
    
    # Th√™m k√Ω t·ª± t·ª´ key
    for char in key:
        if char.isalpha() and char not in used:
            matrix.append(char)
            used.add(char)
    
    # Th√™m c√°c k√Ω t·ª± c√≤n l·∫°i
    for char in "ABCDEFGHIKLMNOPQRSTUVWXYZ":
        if char not in used:
            matrix.append(char)
            used.add(char)
    
    return [matrix[i*5:(i+1)*5] for i in range(5)]

def playfair_find_char(matrix, char):
    """T√¨m v·ªã tr√≠ k√Ω t·ª±"""
    for i in range(5):
        for j in range(5):
            if matrix[i][j] == char:
                return i, j
    return None

def playfair_encrypt(plaintext, key):
    """M√£ h√≥a Playfair"""
    matrix = playfair_create_key_matrix(key)
    plaintext = plaintext.upper().replace('J', 'I')
    plaintext = ''.join(c for c in plaintext if c.isalpha())
    
    # X·ª≠ l√Ω c·∫∑p k√Ω t·ª± tr√πng
    processed = ""
    i = 0
    while i < len(plaintext):
        if i + 1 < len(plaintext) and plaintext[i] == plaintext[i+1]:
            processed += plaintext[i] + 'X'
            i += 1
        else:
            processed += plaintext[i:i+2]
            i += 2
    
    if len(processed) % 2 == 1:
        processed += 'X'
    
    ciphertext = ""
    for i in range(0, len(processed), 2):
        c1, c2 = processed[i], processed[i+1]
        r1, col1 = playfair_find_char(matrix, c1)
        r2, col2 = playfair_find_char(matrix, c2)
        
        if r1 == r2:  # C√πng h√†ng
            ciphertext += matrix[r1][(col1 + 1) % 5] + matrix[r2][(col2 + 1) % 5]
        elif col1 == col2:  # C√πng c·ªôt
            ciphertext += matrix[(r1 + 1) % 5][col1] + matrix[(r2 + 1) % 5][col2]
        else:  # H√¨nh ch·ªØ nh·∫≠t
            ciphertext += matrix[r1][col2] + matrix[r2][col1]
    
    return ciphertext
```

**K·∫øt qu·∫£ th·ª±c nghi·ªám:**
![K·∫øt qu·∫£ 13](/home/lenovo/cryptography_project/results/test3.5.png)

### 3.6 Rabin Cipher - Quadratic Residue

####  **A. L√Ω Thuy·∫øt**

**ƒê·ªãnh nghƒ©a:**
```
M√£ h√≥a: C ‚â° M¬≤ (mod n)
Gi·∫£i m√£: M ‚â° ‚àöC (mod n)

Trong ƒë√≥:
- n = p √ó q (hai s·ªë nguy√™n t·ªë)
- M < ‚àön
```

**ƒê·∫∑c ƒëi·ªÉm:**
- D·ªÖ m√£ h√≥a: b√¨nh ph∆∞∆°ng 1 ph√©p
- Kh√≥ gi·∫£i m√£: t√¨m cƒÉn b·∫≠c 2 mod n
- Ch·ª©ng minh ƒë∆∞·ª£c an to√†n nh∆∞ factorization
- C√≥ 4 cƒÉn b·∫≠c 2 mod n (ambiguity)

####  **B. V√≠ D·ª•**

```
p = 61, q = 53
n = 61 √ó 53 = 3233

M√£ h√≥a M = 65:
C ‚â° 65¬≤ ‚â° 4225 ‚â° 992 (mod 3233)

Gi·∫£i m√£ (c·∫ßn bi·∫øt p, q):
Gi·∫£i 2 ph∆∞∆°ng tr√¨nh:
  M¬≤ ‚â° 992 (mod 61)
  M¬≤ ‚â° 992 (mod 53)

D√πng CRT k·∫øt h·ª£p ‚Üí 4 nghi·ªám c√≥ th·ªÉ
```

####  **C. H√†m Th·ª±c Hi·ªán**

```python
def rabin_encrypt(m, n):
    """M√£ h√≥a Rabin: C = M¬≤ mod n"""
    return (m * m) % n

def rabin_decrypt(c, p, q):
    """
    Gi·∫£i m√£ Rabin
    C·∫ßn bi·∫øt p, q ƒë·ªÉ t√≠nh cƒÉn b·∫≠c 2
    """
    n = p * q
    
    # Gi·∫£i M¬≤ ‚â° c (mod p) v√† M¬≤ ‚â° c (mod q)
    mp = pow(c, (p + 1) // 4, p)
    mq = pow(c, (q + 1) // 4, q)
    
    # D√πng CRT ƒë·ªÉ k·∫øt h·ª£p
    # T√≠nh y sao cho y ‚â° 1 (mod p) v√† y ‚â° 0 (mod q)
    yp = pow(q, -1, p)
    yq = pow(p, -1, q)
    
    r1 = (mp * q * yp + mq * p * yq) % n
    r2 = n - r1
    r3 = (mp * q * yp - mq * p * yq) % n
    r4 = n - r3
    
    return [r1, r2, r3, r4]
```
**K·∫øt qu·∫£ th·ª±c nghi·ªám:**
![K·∫øt qu·∫£ 14](/home/lenovo/cryptography_project/results/test3.6.png)

### So S√°nh C√°c M√£ C·ªï ƒêi·ªÉn

| Lo·∫°i | Kh√≥a | B·∫£o M·∫≠t | T·∫•n C√¥ng | T·ªëc ƒë·ªô |
|------|------|---------|----------|-------|
| **Caesar** | 26 | ‚úó R·∫•t y·∫øu | Brute force O(26n) | C·ª±c nhanh |
| **Substitution** | 26! | ‚úó Y·∫øu | Frequency O(n) | C·ª±c nhanh |
| **Vigen√®re** | m √ó 26^m | ‚ö† Y·∫øu | Kasiski + IC | C·ª±c nhanh |
| **Hill** | (26!)^k¬≤ | ‚ö† Y·∫øu | Known plaintext | Nhanh |
| **Playfair** | 25! | ‚ö† Y·∫øu | Digraph frequency | Nhanh |
| **Rabin** | n = pq | ‚ö† Th∆∞·ªùng | Factorization | Ch·∫≠m |

---

## CH∆Ø∆†NG 4: M√É KH√ìA ƒê·ªêI X·ª®NG HI·ªÜN ƒê·∫†I

### Gi·ªõi ti·ªáu

M√£ kh·ªëi ƒë·ªëi x·ª©ng hi·ªán ƒë·∫°i x√¢y d·ª±ng tr√™n c√°c nguy√™n t·∫Øc:
- **Confusion (Nh·∫ßm l·∫´n):** Quan h·ªá ph·ª©c t·∫°p gi·ªØa plaintext, ciphertext, v√† key
- **Diffusion (Khu·∫øch t√°n):** Thay ƒë·ªïi 1 bit plaintext ‚Üí ·∫£nh h∆∞·ªüng nhi·ªÅu bits ciphertext
- **M·∫°ng Feistel:** K·∫øt h·ª£p c·∫£ 2 nguy√™n t·∫Øc tr√™n

### 4.1 & 4.2 S∆° ƒë·ªì kh·ªëi h·ªá m·∫≠t

**C·∫•u tr√∫c chung:**
```
Plaintext (64/128/256 bits)
    ‚Üì
[Initial Permutation (IP)]
    ‚Üì
[16/32 V√≤ng Feistel]
  - M·ªói v√≤ng: S-boxes + P-boxes + XOR v·ªõi key
    ‚Üì
[Final Permutation (IP^-1)]
    ‚Üì
Ciphertext (64/128/256 bits)
```

**C√°c b∆∞·ªõc ch√≠nh:**
1. **Key Schedule:** Sinh kh√≥a v√≤ng t·ª´ master key
2. **Initial Permutation:** Ho√°n v·ªã ban ƒë·∫ßu
3. **Round Function:** L·∫∑p l·∫°i v·ªõi m·ªói kh√≥a v√≤ng
4. **Final Permutation:** Ho√°n v·ªã cu·ªëi c√πng

### 4.3 M√£ Kh·ªëi & Chuy·ªÉn V·ªã

**M√£ kh·ªëi (Block Cipher):**
- Chia d·ªØ li·ªáu th√†nh c√°c kh·ªëi c·ªë ƒë·ªãnh
- M√£ h√≥a t·ª´ng kh·ªëi ƒë·ªôc l·∫≠p
- DES: 64-bit blocks
- AES: 128-bit blocks

**Chuy·ªÉn V·ªã (Permutation):**
```
V√≠ d·ª• 8-bit permutation:
Input:  10110010 (v·ªã tr√≠ 1 2 3 4 5 6 7 8)
Table:  [8 6 4 2 7 5 3 1]
Output: 01011001

Gi·∫£i th√≠ch: 
Output[0] = Input[8-1] = Input[7] = 0
Output[1] = Input[6-1] = Input[5] = 1
Output[2] = Input[4-1] = Input[3] = 0
...
```

### 4.4 P-box (Permutation Box)

####  **A. ƒê·ªãnh Nghƒ©a**

**P-box:** Ch·ªâ th·ª±c hi·ªán ho√°n v·ªã c√°c bits, kh√¥ng thay ƒë·ªïi gi√° tr·ªã

**C√¥ng th·ª©c:**
```
Output[i] = Input[Permutation_table[i]]
```

####  **B. 3 Lo·∫°i P-box**

**1. Straight P-box (Ho√°n v·ªã th·∫≥ng):**
```
K√≠ch th∆∞·ªõc input = K√≠ch th∆∞·ªõc output = n
M·ªói bit input ƒë∆∞·ª£c ho√°n v·ªã ƒë·∫øn 1 v·ªã tr√≠ output

V√≠ d·ª• 8-bit:
Input:  b‚ÇÅ b‚ÇÇ b‚ÇÉ b‚ÇÑ b‚ÇÖ b‚ÇÜ b‚Çá b‚Çà
Table:  [8 6 4 2 7 5 3 1]
Output: b‚Çà b‚ÇÜ b‚ÇÑ b‚ÇÇ b‚Çá b‚ÇÖ b‚ÇÉ b‚ÇÅ
```

**2. Expansion P-box (M·ªü r·ªông):**
```
K√≠ch th∆∞·ªõc output > K√≠ch th∆∞·ªõc input
M·ªôt s·ªë bits ƒë∆∞·ª£c l·∫∑p l·∫°i

DES Expansion (32 ‚Üí 48 bits):
Input:  32 bits
Output: 48 bits (m·ªôt s·ªë bits ƒë∆∞·ª£c d√πng 2 l·∫ßn)

V√≠ d·ª•:
Table: [32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, ...]
       (bit 4 v√† 5 xu·∫•t hi·ªán 2 l·∫ßn)
```

**3. Compression P-box (N√©n):**
```
K√≠ch th∆∞·ªõc output < K√≠ch th∆∞·ªõc input
B·ªè ƒëi m·ªôt s·ªë bits

DES Compression (56 ‚Üí 48 bits):
Input:  56 bits
Output: 48 bits (8 bits b·ªã lo·∫°i b·ªè)
```

####  **C. H√†m Th·ª±c Hi·ªán**

```python
def permutation_box(input_bits, permutation_table):
    """
    P-box (Permutation box)
    
    Tham s·ªë:
    - input_bits: S·ªë nguy√™n (c√°c bits ƒë·∫ßu v√†o)
    - permutation_table: Danh s√°ch c√°c v·ªã tr√≠ (1-indexed)
    
    V√≠ d·ª•:
    input_bits = 0b10110010
    perm_table = [8, 6, 4, 2, 7, 5, 3, 1]
    Output bit 0 = Input bit 7 (8-1)
    """
    output = 0
    for i, perm_idx in enumerate(permutation_table):
        if (input_bits >> (perm_idx - 1)) & 1:
            output |= (1 << (len(permutation_table) - 1 - i))
    return output

def expansion_box(input_bits, expansion_table):
    """
    Expansion P-box: M·ªü r·ªông 32 ‚Üí 48 bits (DES)
    M·ªôt s·ªë bits ƒë∆∞·ª£c l·∫∑p l·∫°i
    """
    output = 0
    for i, exp_idx in enumerate(expansion_table):
        if (input_bits >> (exp_idx - 1)) & 1:
            output |= (1 << (len(expansion_table) - 1 - i))
    return output

def straight_pbox(input_bits, pbox_table):
    """Straight P-box - Ch·ªâ ho√°n v·ªã"""
    return permutation_box(input_bits, pbox_table)

def compression_pbox(input_bits, compression_table):
    """Compression P-box - N√©n d·ªØ li·ªáu"""
    return permutation_box(input_bits, compression_table)
```

####  **D. V√≠ D·ª• Chi Ti·∫øt**

```
Straight P-box 8-bit:
Input:  10110010 (0xB2)
Table:  [8, 6, 4, 2, 7, 5, 3, 1]

T√≠nh to√°n:
Output[0] = Input[8-1] = Input[7] = 0
Output[1] = Input[6-1] = Input[5] = 1
Output[2] = Input[4-1] = Input[3] = 0
Output[3] = Input[2-1] = Input[1] = 1
Output[4] = Input[7-1] = Input[6] = 1
Output[5] = Input[5-1] = Input[4] = 1
Output[6] = Input[3-1] = Input[2] = 0
Output[7] = Input[1-1] = Input[0] = 1

Output: 01011101 (0x5D) ‚úì
```
**K·∫øt qu·∫£ th·ª±c nghi·ªám:**
![K·∫øt qu·∫£ 15](/home/lenovo/cryptography_project/results/test4.1.png)

### 4.5 S-box (Substitution Box)

####  **A. ƒê·ªãnh Nghƒ©a**

**S-box:** B·∫£ng lookup (LUT) th·ª±c hi·ªán thay th·∫ø (substitution)
- Kh√¥ng ph·∫£i xor ho·∫∑c AND/OR
- Cung c·∫•p **t√≠nh phi tuy·∫øn** (nonlinearity)
- M·ªói ƒë·∫ßu v√†o ‚Üí ƒë·∫ßu ra duy nh·∫•t

####  **B. C·∫•u Tr√∫c**

**DES S-boxes:**
```
8 S-boxes (S1 ƒë·∫øn S8)
M·ªói box: 6 bits input ‚Üí 4 bits output
B·∫£ng: 4 h√†ng √ó 16 c·ªôt = 64 ph·∫ßn t·ª≠

Row index = bit 0 + bit 5 (2 bit ngo√†i)
Col index = bits 1-4 (4 bit trong)
```

**AES S-box (Rijndael):**
```
1 S-box
8 bits input ‚Üí 8 bits output
B·∫£ng: 16 √ó 16 = 256 ph·∫ßn t·ª≠

T√≠nh to√°n: 
1. T√¨m ph·∫ßn t·ª≠ ngh·ªãch ƒë·∫£o trong GF(2^8)
2. √Åp d·ª•ng bi·∫øn ƒë·ªïi affine
```

####  **C. H√†m Th·ª±c Hi·ªán**

```python
# DES S1 box
DES_S1 = [
    [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
    [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
    [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 0, 5],
    [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]
]

def substitution_box(input_6bits, sbox):
    """
    S-box: 6 bits ‚Üí 4 bits
    
    V√≠ d·ª• DES S1:
    Input: 011011 (27)
    Row = bit 0 + (bit 5 << 1) = 1 + 0 = 1
    Col = bits 1-4 = 1101 = 13
    Output = sbox[1][13] = 1
    """
    row = ((input_6bits >> 5) & 1) | (((input_6bits) & 1) << 1)
    col = (input_6bits >> 1) & 0xF
    return sbox[row][col]
```

####  **D. V√≠ D·ª• Chi Ti·∫øt**

```
DES S1 box, Input: 011011 (6 bits)

B∆∞·ªõc 1: T√¨m row
  Bit 0 (ngo√†i c√πng ph·∫£i) = 1
  Bit 5 (ngo√†i c√πng tr√°i) = 0
  Row = 0 | (1 << 1) = 2

B∆∞·ªõc 2: T√¨m col
  Bits 1-4 (gi·ªØa) = 1101 = 13
  Col = 13

B∆∞·ªõc 3: Tra c·ª©u b·∫£ng
  DES_S1[2][13] = 0

Output: 0000 (4 bits) ‚úì
```

### 4.6 Feistel Network

####  **A. L√Ω Thuy·∫øt**

**C·∫•u tr√∫c Feistel:**
```
V√≤ng i:
  L_{i+1} = R_i
  R_{i+1} = L_i ‚äï f(R_i, K_i)

Trong ƒë√≥:
- L_i, R_i: N·ª≠a tr√°i/ph·∫£i
- f(): H√†m v√≤ng (round function)
- K_i: Kh√≥a v√≤ng
- ‚äï: XOR
```

**∆Øu ƒëi·ªÉm:**
1. **ƒê·∫£m b·∫£o invertibility:** D·ªÖ gi·∫£i m√£
2. **H√†m f kh√¥ng c·∫ßn kh·∫£ ngh·ªãch:** Kh√¥ng ph·∫£i h√†m m·ªôt-m·ªôt
3. **C√πng c·∫•u tr√∫c cho encrypt/decrypt:** Ch·ªâ ƒë·∫£o ng∆∞·ª£c th·ª© t·ª± kh√≥a

####  **B. H√†m V√≤ng f()**

**Th√†nh ph·∫ßn:**
```
f(R, K) = [P-box(S-boxes(expansion(R) ‚äï K))]

B∆∞·ªõc:
1. Expansion: 32 ‚Üí 48 bits (l·∫∑p l·∫°i bit)
2. XOR v·ªõi K: 48 ‚äï 48
3. S-boxes: 48 ‚Üí 32 bits (8 S-boxes 6‚Üí4)
4. P-box: Ho√°n v·ªã 32 bits
```

####  **C. H√†m Th·ª±c Hi·ªán**

```python
def feistel_round(left, right, round_key, sbox_tables=None, pbox_table=None):
    """
    M·ªôt v√≤ng Feistel
    
    C√¥ng th·ª©c:
    L' = R
    R' = L XOR f(R, K)
    """
    # Round function (ƒë∆°n gi·∫£n)
    f_output = right ^ round_key
    
    # N·∫øu c√≥ S-boxes
    if sbox_tables:
        # Chia th√†nh 8 kh·ªëi 6-bit v√† thay th·∫ø
        substituted = 0
        for i in range(8):
            input_6bits = (f_output >> (42 - 6*i)) & 0x3F
            output_4bits = substitution_box(input_6bits, sbox_tables[i])
            substituted |= (output_4bits << (28 - 4*i))
        f_output = substituted
    
    new_left = right
    new_right = left ^ f_output
    
    return new_left, new_right

def feistel_encrypt(plaintext, keys, rounds=16):
    """
    M√£ h√≥a Feistel (v√≠ d·ª• DES)
    
    plaintext: 64 bits
    keys: Danh s√°ch kh√≥a v√≤ng (16 kh√≥a)
    rounds: S·ªë v√≤ng (DES = 16)
    """
    # Chia plaintext th√†nh 2 n·ª≠a 32-bit
    left = plaintext >> 32
    right = plaintext & 0xFFFFFFFF
    
    # 16 v√≤ng Feistel
    for i in range(rounds):
        left, right = feistel_round(left, right, keys[i])
    
    # Ho√°n ƒë·ªïi cu·ªëi c√πng (swap)
    left, right = right, left
    
    # K·∫øt h·ª£p 2 n·ª≠a
    ciphertext = (left << 32) | right
    return ciphertext

def feistel_decrypt(ciphertext, keys, rounds=16):
    """
    Gi·∫£i m√£ Feistel (s·ª≠ d·ª•ng keys theo th·ª© t·ª± ng∆∞·ª£c)
    
    Ch·ªâ c·∫ßn ƒë·∫£o ng∆∞·ª£c th·ª© t·ª± kh√≥a v√≤ng
    """
    return feistel_encrypt(ciphertext, keys[::-1], rounds)
```

####  **D. V√≠ D·ª• Chi Ti·∫øt**

```
V√≤ng 1 c·ªßa Feistel:
L‚ÇÄ = 0x12345678
R‚ÇÄ = 0x9ABCDEF0
K‚ÇÅ = 0xF00DBEEF

T√≠nh to√°n:
1. f(R‚ÇÄ, K‚ÇÅ) = f(0x9ABCDEF0, 0xF00DBEEF)
   - Expansion: 32 ‚Üí 48 bits
   - XOR: 48 ‚äï 48
   - S-boxes: 48 ‚Üí 32 bits
   - P-box: Ho√°n v·ªã
   - f_output = 0x12345678 (v√≠ d·ª•)

2. L‚ÇÅ = R‚ÇÄ = 0x9ABCDEF0
   R‚ÇÅ = L‚ÇÄ ‚äï f_output = 0x12345678 ‚äï 0x12345678 = 0x00000000

Sau v√≤ng 1:
L‚ÇÅ = 0x9ABCDEF0
R‚ÇÅ = 0x00000000
```

**K·∫øt qu·∫£ th·ª±c nghi·ªám:**
![K·∫øt qu·∫£ 16](/home/lenovo/cryptography_project/results/test4.2.png)

### 4.7 K·∫øt H·ª£p P-box & S-box & Feistel

####  **A. C·∫•u Tr√∫c DES (Data Encryption Standard)**

```
DES (64-bit plaintext, 56-bit key):

1. Initial Permutation (IP): 64 ‚Üí 64 bits (ho√°n v·ªã)
2. 16 v√≤ng Feistel:
   - M·ªói v√≤ng:
     a. Expansion: 32 ‚Üí 48 bits
     b. XOR v·ªõi K_i: 48 ‚äï 48
     c. S-boxes: 48 ‚Üí 32 bits (8 S-boxes 6‚Üí4)
     d. P-box: Ho√°n v·ªã 32 bits
     e. XOR v·ªõi L_i
3. Final Permutation (IP^-1): 64 ‚Üí 64 bits
```

####  **B. Confusion & Diffusion**

**Confusion (S-boxes):**
```
- Thay ƒë·ªïi phi tuy·∫øn c√°c bits
- M·ªói output bit ph·ª• thu·ªôc v√†o nhi·ªÅu input bits
- Khi·∫øn key kh√≥ ƒë∆∞·ª£c x√°c ƒë·ªãnh t·ª´ plaintext/ciphertext
```

**Diffusion (P-boxes & Feistel):**
```
- Ho√°n v·ªã c√°c bits
- Thay ƒë·ªïi 1 bit plaintext ‚Üí ·∫£nh h∆∞·ªüng nhi·ªÅu bits ciphertext
- Sau n v√≤ng: 1 bit thay ƒë·ªïi ‚Üí ~n√ó2 bits output thay ƒë·ªïi (avalanche effect)
```

####  **C. H√†m Th·ª±c Hi·ªán**

```python
class BlockCipherStructure:
    """C·∫•u tr√∫c chung c·ªßa m√£ kh·ªëi hi·ªán ƒë·∫°i"""
    
    def __init__(self, block_size=64, key_size=56):
        """
        block_size: k√≠ch th∆∞·ªõc kh·ªëi (bit)
        key_size: k√≠ch th∆∞·ªõc kh√≥a (bit)
        """
        self.block_size = block_size
        self.key_size = key_size
        self.rounds = 16
    
    def key_schedule(self, master_key):
        """L·ªãch sinh kh√≥a - Sinh c√°c kh√≥a v√≤ng t·ª´ master key"""
        round_keys = []
        for i in range(self.rounds):
            # ƒê∆°n gi·∫£n h√≥a: xoay master key
            round_key = (
                (master_key << (i + 1)) | 
                (master_key >> (self.key_size - i - 1))
            ) & ((1 << self.key_size) - 1)
            round_keys.append(round_key)
        return round_keys
    
    def initial_permutation(self, plaintext):
        """Initial Permutation (IP)"""
        return plaintext
    
    def final_permutation(self, plaintext):
        """Final Permutation (IP^-1)"""
        return plaintext
    
    def encrypt(self, plaintext, key):
        """M√£ h√≥a"""
        round_keys = self.key_schedule(key)
        ciphertext = self.initial_permutation(plaintext)
        ciphertext = feistel_encrypt(ciphertext, round_keys, self.rounds)
        ciphertext = self.final_permutation(ciphertext)
        return ciphertext
    
    def decrypt(self, ciphertext, key):
        """Gi·∫£i m√£"""
        round_keys = self.key_schedule(key)
        plaintext = self.initial_permutation(ciphertext)
        plaintext = feistel_decrypt(plaintext, round_keys, self.rounds)
        plaintext = self.final_permutation(plaintext)
        return plaintext
```

**K·∫øt qu·∫£ th·ª±c nghi·ªám:**
![K·∫øt qu·∫£ 17](/home/lenovo/cryptography_project/results/test4.345.png)

### T√≠nh Ch·∫•t B·∫£o M·∫≠t

| T√≠nh Ch·∫•t | Ph·∫ßn T·ª≠ | M·ª•c ƒê√≠ch |
|-----------|---------|----------|
| **Confusion** | S-boxes | Thay ƒë·ªïi phi tuy·∫øn |
| **Diffusion** | P-boxes + Feistel | Ho√°n v·ªã & khu·∫øch t√°n |
| **Invertibility** | Feistel structure | D·ªÖ gi·∫£i m√£ |
| **Avalanche Effect** | Nhi·ªÅu v√≤ng | 1 bit ‚Üí nhi·ªÅu bits thay ƒë·ªïi |

---

## CH∆Ø∆†NG 5: M√É DES (DATA ENCRYPTION STANDARD)

### Gi·ªõi Thi·ªáu

DES (Data Encryption Standard) ƒë∆∞·ª£c ph√°t h√†nh nƒÉm 1977, d·ª±a tr√™n Feistel Network v·ªõi:
- Kh√≥a: 56-bit (+ 8 bits parity = 64-bit input)
- Kh·ªëi: 64-bit
- V√≤ng: 16 v√≤ng Feistel
- S-boxes: 8 c√°i (6‚Üí4 bits)
- P-boxes: Ho√°n v·ªã bits

### 5.1 C·∫•u Tr√∫c DES

####  **A. S∆° ƒê·ªì Kh·ªëi T·ªïng Qu√°t**

```
INPUT (64-bit plaintext)
    ‚Üì
[Initial Permutation (IP)]
    ‚Üì
[Split into L‚ÇÄ, R‚ÇÄ] (m·ªói 32-bit)
    ‚Üì
[16 v√≤ng Feistel]
    ‚Üì
[Final Swap: R‚ÇÅ‚ÇÜ || L‚ÇÅ‚ÇÜ]
    ‚Üì
[Final Permutation (IP‚Åª¬π)]
    ‚Üì
OUTPUT (64-bit ciphertext)
```

####  **B. H√†m Feistel f(R, K)**

**C√¥ng th·ª©c:**
```
f(R, K) = P-box(S-boxes(E(R) ‚äï K))

B∆∞·ªõc chi ti·∫øt:
1. Expansion: E(R)   [32 ‚Üí 48 bits]
2. XOR v·ªõi K: E(R) ‚äï K   [48 bits]
3. S-box sub: S‚ÇÅ...S‚Çà    [48 ‚Üí 32 bits]
4. P-box perm: P         [32 ‚Üí 32 bits]
```

####  **C. Key Schedule**

**B∆∞·ªõc 1: Permuted Choice 1 (PC-1)**
```
Input: 64-bit key (v·ªõi 8 parity bits ·ªü v·ªã tr√≠ 8, 16, 24, 32, 40, 48, 56, 64)
Output: 56-bit key (lo·∫°i b·ªè parity bits)
Split: C‚ÇÄ (28-bit), D‚ÇÄ (28-bit)
```

**B∆∞·ªõc 2: Key Schedule Loop**
```
For i = 1 to 16:
  - Left shift: C·µ¢ = LS(C·µ¢‚Çã‚ÇÅ), D·µ¢ = LS(D·µ¢‚Çã‚ÇÅ)
    (Shift 1 bit n·∫øu i ‚àà {1, 2, 9, 16}; shift 2 bits kh√°c)
  - K·µ¢ = PC-2(C·µ¢ || D·µ¢)  [56 ‚Üí 48 bits]
```

####  **D. V√≠ D·ª• Chi Ti·∫øt**

```
Plaintext: 0x0123456789ABCDEF (64 bits)
Key:       0x133457799BBCDFF1 (64 bits, v·ªõi parity)

B∆∞·ªõc 1: Initial Permutation (IP)
  Input:  0x0123456789ABCDEF
  Output: L‚ÇÄ = 0xCC00CCFF
          R‚ÇÄ = 0xF0AAF0AA

B∆∞·ªõc 2: V√≤ng 1
  K‚ÇÅ = 0x1B02468ACE (48 bits t·ª´ key schedule)
  f(R‚ÇÄ, K‚ÇÅ) = ... = 0xF0XX_XXXX
  L‚ÇÅ = R‚ÇÄ = 0xF0AAF0AA
  R‚ÇÅ = L‚ÇÄ ‚äï f(R‚ÇÄ, K‚ÇÅ) = 0xCC00CCFF ‚äï f(R‚ÇÄ, K‚ÇÅ) = 0x3C56_9C55

B∆∞·ªõc 3: V√≤ng 2-16: L·∫∑p l·∫°i v·ªõi K‚ÇÇ...K‚ÇÅ‚ÇÜ

B∆∞·ªõc 4: Final Swap & Final Permutation (IP‚Åª¬π)
  Output: 0x85E813540F0AB405
```

### 5.2 ƒêi·ªÉm Y·∫øu c·ªßa DES

####  **1. K√≠ch Th∆∞·ªõc Kh√≥a Nh·ªè: 56 bits**

**Kh√¥ng gian kh√≥a:**
```
2^56 ‚âà 7.2 √ó 10^16 kh√≥a c√≥ th·ªÉ

Timeline t·∫•n c√¥ng:
1977: DES ƒë∆∞·ª£c chu·∫©n h√≥a (ƒë·ªß an to√†n)
1998: EFF Deep Crack - t√¨m kh√≥a trong 56 gi·ªù
2024: GPU brute force - v√†i gi·ªù
```

**·ª®ng d·ª•ng:**
```
V√≠ d·ª• m√£ h√≥a t·∫•t c·∫£ kh√≥a 56-bit:
- Th·ª≠ 10^15 kh√≥a/gi√¢y
- C·∫ßn ~7200 gi√¢y = 2 gi·ªù
```

#### **2. K√≠ch Th∆∞·ªõc Kh·ªëi Nh·ªè: 64 bits**

**Birthday Attack:**
```
T√≠nh ch·∫•t: Sau ‚àö(2^64) = 2^32 kh·ªëi (~4 t·ª∑ kh·ªëi), 
           x√°c su·∫•t collision > 50%

·ª®ng d·ª•ng: ~16 EB d·ªØ li·ªáu ‚Üí nguy hi·ªÉm!
```

#### **3. Weak Keys**

```
4 weak keys (encryption = decryption):
- 0x0101010101010101
- 0xFEFEFEFEFEFEFEFE
- 0xE0E0E0E0F1F1F1F1
- 0x1F1F1F1F0E0E0E0E

Nguy√™n nh√¢n: Key schedule sinh K‚ÇÅ = K‚ÇÇ = ... = K‚ÇÅ‚ÇÜ
```

### 5.3 Triple DES (3DES)

#### **A. ƒê·ªãnh Nghƒ©a**

**3DES (EDE mode - Encrypt-Decrypt-Encrypt):**
```
Ciphertext = E(D(E(Plaintext, K‚ÇÅ), K‚ÇÇ), K‚ÇÉ)

N·∫øu K‚ÇÅ = K‚ÇÉ (2-key 3DES):
Ciphertext = E(D(E(P, K‚ÇÅ), K‚ÇÇ), K‚ÇÅ)
K√≠ch th∆∞·ªõc kh√≥a: ~112 bits
```

#### **B. V√≠ D·ª•**

```
Plaintext: 0x0123456789ABCDEF
K‚ÇÅ = 0x0123456789ABCDEF
K‚ÇÇ = 0xFEDCBA9876543210
K‚ÇÉ = K‚ÇÅ

Step 1: T‚ÇÅ = E(P, K‚ÇÅ)  = 0x85E813540F0AB405
Step 2: T‚ÇÇ = D(T‚ÇÅ, K‚ÇÇ) = 0x... (gi·∫£i m√£ v·ªõi K‚ÇÇ)
Step 3: C = E(T‚ÇÇ, K‚ÇÉ)  = 0x... (m√£ h√≥a l·∫°i v·ªõi K‚ÇÉ)

Output: Ciphertext
```

####  **C. So S√°nh DES vs 3DES**

| Ti√™u ch√≠ | DES | 3DES |
|----------|-----|------|
| Kh√≥a | 56-bit | 168-bit (2-key: 112-bit) |
| Kh·ªëi | 64-bit | 64-bit |
| V√≤ng | 16 | 48 (3√ó16) |
| T·ªëc ƒë·ªô | Nhanh | 1/3 DES |
| B·∫£o m·∫≠t | ‚úó L·ªói th·ªùi | ‚ö† Legacy (d·∫ßn thay AES) |

### 5.4 T·∫•n C√¥ng Meet-in-the-Middle l√™n 2DES

####  **Kh√°i Ni·ªám**

```
2DES: C = E(E(P, K‚ÇÅ), K‚ÇÇ)

Thay v√¨ th·ª≠ 2^112 kh√≥a, t·∫•n c√¥ng M-i-M:
1. T√≠nh E(P, K‚ÇÅ) v·ªõi t·∫•t c·∫£ 2^56 kh√≥a K‚ÇÅ
   ‚Üí L∆∞u v√†o b·∫£ng hash H

2. T√≠nh D(C, K‚ÇÇ) v·ªõi t·∫•t c·∫£ 2^56 kh√≥a K‚ÇÇ
   ‚Üí T√¨m trong b·∫£ng H

3. N·∫øu t√¨m th·∫•y: (K‚ÇÅ*, K‚ÇÇ*) l√† kh√≥a ƒë√∫ng!

Ph·ª©c t·∫°p: 2^56 + 2^56 = 2^57 (ch·ªâ t·ªën 1 bit!)
```

####  **V√≠ D·ª•**

```
P = 0x0123456789ABCDEF
K‚ÇÅ = 0x0123456789ABCDEF
K‚ÇÇ = 0xFEDCBA9876543210
C = E(E(P, K‚ÇÅ), K‚ÇÇ) = 0x85E813540F0AB405

T·∫•n c√¥ng:
1. T√≠nh T = E(P, K‚ÇÅ) cho t·∫•t c·∫£ K‚ÇÅ:
   K‚ÇÅ = 0x0123456789ABCDEF ‚Üí T = 0x85E813540F0AB405
   ...

2. T√≠nh D(C, K‚ÇÇ) cho t·∫•t c·∫£ K‚ÇÇ:
   K‚ÇÇ = 0xFEDCBA9876543210 ‚Üí D(C, K‚ÇÇ) = 0x85E813540F0AB405
   ...

3. Match! ‚Üí (K‚ÇÅ, K‚ÇÇ) t√¨m ƒë∆∞·ª£c
```

### K·∫øt Qu·∫£ Ki·ªÉm Th·ª≠
**K·∫øt qu·∫£ th·ª±c nghi·ªám:**
![K·∫øt qu·∫£ 18](/home/lenovo/cryptography_project/results/test6-des.png)
![K·∫øt qu·∫£ 19](/home/lenovo/cryptography_project/results/test6-des2.png)

### 5.5 C∆° Ch·∫ø Ho·∫°t ƒê·ªông Chi Ti·∫øt

####  **A. S-box DES S1 (V√≠ d·ª•)**

```
Input: 6 bits = 011011 (row 2, col 13)
Output: DES_S1[2][13] = 5 (4 bits = 0101)

L·ª£i √≠ch: Phi tuy·∫øn h√≥a, ch·ªëng frequency analysis
```

####  **B. Initial & Final Permutation**

```
IP (Initial Permutation):
Nh·∫±m m·ª•c ƒë√≠ch (theo Coppersmith):
- V·ªã tr√≠ c·ªßa bits ph√°t huy t√°c d·ª•ng v·ªõi S-boxes ƒë·∫ßu ti√™n
- L√†m cho bit 1 c·ªßa plaintext ·∫£nh h∆∞·ªüng ƒë·∫øn S-box 1

IP‚Åª¬π (Final Permutation):
- ƒê·∫£o ng∆∞·ª£c c·ªßa IP
- Kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn b·∫£o m·∫≠t (ch·ªâ l√† ho√°n v·ªã)
```

### K·∫øt Lu·∫≠n

**DES:**
- ‚úì C√≥ l·ªãch s·ª≠ quan tr·ªçng (c√¥ng c·ª• m·∫≠t m√£ ƒë·∫ßu ti√™n ƒë∆∞·ª£c ti√™u chu·∫©n h√≥a)
- ‚úì C·∫•u tr√∫c Feistel r·∫•t ƒë·∫πp (d·ªÖ hi·ªÉu, d·ªÖ ph√¢n t√≠ch)
- ‚úó Kh√≥a qu√° nh·ªè (56-bit) ‚Üí L·ªói th·ªùi
- ‚úó Kh·ªëi qu√° nh·ªè (64-bit) ‚Üí Nguy hi·ªÉm v·ªõi d·ªØ li·ªáu l·ªõn

**3DES:**
- ‚ö† C·∫£i thi·ªán (112-168 bit kh√≥a)
- ‚ö† C√≤n s·ª≠ d·ª•ng (legacy systems)
- ‚úó Ch·∫≠m (3x DES)
- ‚Üí **N√™n thay b·∫±ng AES**

**M·∫≠t m√£ hi·ªán ƒë·∫°i h∆°n:**
- **Hi·ªán ƒë·∫°i:** AES-128, AES-256
- **T∆∞∆°ng lai:** ChaCha20 ho·∫∑c ti√™u chu·∫©n m·ªõi

**File code:** `Chuong5_MaDES/DES.py`

---

## CH∆Ø∆†NG 6: M√É AES (ADVANCED ENCRYPTION STANDARD)

### Gi·ªõi Thi·ªáu

AES (Advanced Encryption Standard) ƒë∆∞·ª£c ph√°t h√†nh nƒÉm 2001, thay th·∫ø DES:
- Kh√≥a: 128/192/256-bit
- Kh·ªëi: 128-bit (c·ªë ƒë·ªãnh)
- V√≤ng: 10/12/14 (ph·ª• thu·ªôc kh√≥a)
- C·∫•u tr√∫c: SPN (Substitution-Permutation Network) ch·ª© kh√¥ng ph·∫£i Feistel
- S-boxes: 1 c√°i (8‚Üí8 bits, d·ª±a tr√™n GF(2^8))

### 6.1 So S√°nh DES vs AES

| Ti√™u ch√≠ | DES | AES |
|----------|-----|-----|
| **Kh√≥a** | 56-bit | 128/192/256-bit |
| **Kh·ªëi** | 64-bit | 128-bit (c·ªë ƒë·ªãnh) |
| **V√≤ng** | 16 | 10/12/14 |
| **C·∫•u tr√∫c** | Feistel | SPN (Substitution-Permutation) |
| **S-box** | 8 √ó (6‚Üí4 bits) | 1 √ó (8‚Üí8 bits) |
| **T·ªëc ƒë·ªô** | Ch·∫≠p | Nhanh (~3-5x DES) |
| **B·∫£o m·∫≠t** | ‚úó L·ªói th·ªùi | ‚úì Hi·ªán ƒë·∫°i |

### 6.2 C√°c Ph√©p Bi·∫øn ƒê·ªïi AES

####  **A. SubBytes (S-box Substitution)**

**C√¥ng th·ª©c (trong GF(2^8)):**
```
S(x) = M √ó x^(-1) + c

Trong ƒë√≥:
- x^(-1): Ngh·ªãch ƒë·∫£o nh√¢n trong GF(2^8)
  (GF(2^8) x√°c ƒë·ªãnh b·ªüi ƒëa th·ª©c t·ªëi gi·∫£n p(x) = x^8 + x^4 + x^3 + x + 1)
- M: Ma tr·∫≠n 8√ó8 affine transformation
- c: H·∫±ng s·ªë 0x63
```

**V√≠ D·ª• Chi Ti·∫øt:**
```
Input: 0x53 (k√Ω t·ª± 'S')

B∆∞·ªõc 1: T√≠nh 0x53^(-1) trong GF(2^8)
  0x53 = 01010011
  (D√πng extended GCD ho·∫∑c lookup table)
  0x53^(-1) = 0xCA

B∆∞·ªõc 2: √Åp d·ª•ng affine transformation
  [0xCA] √ó [matrix M] + 0x63 (mod 2)
  = 0xED

Output: 0xED
```

**T√≠nh Ch·∫•t:**
- ‚úì Phi tuy·∫øn (ch·ªëng linear cryptanalysis)
- ‚úì T·ªëi ƒëa ƒë·ªô ch√™nh l·ªách (ch·ªëng differential cryptanalysis)
- ‚úì B·∫£ng S-box chu·∫©n (kh√¥ng c√≥ backdoor)
- ‚úì C√≥ inverse S-box ƒë·ªÉ gi·∫£i m√£

**B·∫£ng S-box AES (16√ó16, ch·ª©a t·∫•t c·∫£ 256 gi√° tr·ªã):**
```
   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
0: 63 7C 77 7B F2 6B 6F C5 30 01 67 2B FE D7 AB 76
1: CA 82 C9 7D FA 59 47 F0 AD D4 A2 AF 9C A4 72 C0
...
```

####  **B. ShiftRows (H√†ng D·ªãch)**

**C√¥ng Th·ª©c:**
```
State (4√ó4 matrix):
Row 0: kh√¥ng d·ªãch
Row 1: d·ªãch tr√°i 1 byte
Row 2: d·ªãch tr√°i 2 bytes
Row 3: d·ªãch tr√°i 3 bytes
```

**V√≠ D·ª• Chi Ti·∫øt:**
```
Tr∆∞·ªõc ShiftRows:
[S00  S04  S08  S0C]     [00  04  08  0C]
[S10  S14  S18  S1C]  =  [01  05  09  0D]
[S20  S24  S28  S2C]     [02  06  0A  0E]
[S30  S34  S38  S3C]     [03  07  0B  0F]

Sau ShiftRows:
[S00  S04  S08  S0C]     [00  04  08  0C]
[S14  S18  S1C  S10]  =  [05  09  0D  01]  (d·ªãch 1 byte)
[S28  S2C  S20  S24]     [0A  0E  02  06]  (d·ªãch 2 bytes)
[S3C  S30  S34  S38]     [0F  03  07  0B]  (d·ªãch 3 bytes)
```

**M·ª•c ƒê√≠ch:**
- ‚úì T·∫°o diffusion: Thay ƒë·ªïi 1 byte ‚Üí ·∫¢nh h∆∞·ªüng nhi·ªÅu byte ·ªü v√≤ng sau
- ‚úì K·∫øt h·ª£p v·ªõi SubBytes ƒë·ªÉ t·∫°o confusion + diffusion


####  **C. MixColumns (Tr·ªôn C·ªôt)**

**C√¥ng Th·ª©c (trong GF(2^8)):**
```
[s'‚ÇÄ,‚±º]   [02 03 01 01] [s‚ÇÄ,‚±º]
[s'‚ÇÅ,‚±º] = [01 02 03 01] [s‚ÇÅ,‚±º]  (‚äó trong GF(2^8))
[s'‚ÇÇ,‚±º]   [01 01 02 03] [s‚ÇÇ,‚±º]
[s'‚ÇÉ,‚±º]   [03 01 01 02] [s‚ÇÉ,‚±º]

Trong GF(2^8), c√°c ph√©p to√°n kh√°c v·ªõi s·ªë th·ª±c:
- ‚äï l√† XOR (kh√¥ng ph·∫£i c·ªông)
- ‚äó l√† ph√©p nh√¢n Galois (kh√¥ng ph·∫£i nh√¢n th∆∞·ªùng)
```

**Ph√©p Nh√¢n Galois:**
```
02 ‚äó 87:
  87 = 10000111
  Nh√¢n v·ªõi 2: 1 0000111 0 = 0001 1110 (shift tr√°i)
  N·∫øu overflow (bit cao = 1): XOR v·ªõi 0x1B (polynomial t·ªëi gi·∫£n)
  10001110 XOR 00011011 = 10010101 = 0x95

03 ‚äó 87:
  03 = 02 + 01 (trong GF)
  03 ‚äó 87 = (02 ‚äó 87) ‚äï (01 ‚äó 87)
           = 0x95 ‚äï 0x87
           = 0x12
```

**V√≠ D·ª• Chi Ti·∫øt (1 c·ªôt):**
```
Column: [87, 6E, 46, A6]·µÄ

s'‚ÇÄ = (02‚äó87) ‚äï (03‚äó6E) ‚äï (01‚äó46) ‚äï (01‚äóA6)

T√≠nh to√°n:
  02‚äó87 = 0x95
  03‚äó6E = 0x16
  01‚äó46 = 0x46
  01‚äóA6 = 0xA6
  
  s'‚ÇÄ = 0x95 ‚äï 0x16 ‚äï 0x46 ‚äï 0xA6 = 0x47

(T∆∞∆°ng t·ª± cho s'‚ÇÅ, s'‚ÇÇ, s'‚ÇÉ)

Result: [47, XX, XX, XX]·µÄ
```

**M·ª•c ƒê√≠ch:**
- ‚úì Diffusion m·∫°nh: 1 bit thay ƒë·ªïi ‚Üí ·∫¢nh h∆∞·ªüng 4 c·ªôt
- ‚úì K·∫øt h·ª£p SubBytes + ShiftRows + MixColumns ‚Üí R·∫•t kh√≥ ph√¢n t√≠ch
- ‚úì B·∫£o v·ªá ch·ªëng differential & linear cryptanalysis


####  **D. AddRoundKey (XOR Kh√≥a V√≤ng)**

**C√¥ng Th·ª©c:**
```
State ‚Üê State ‚äï RoundKey[round]

C√°c kh√≥a v√≤ng sinh t·ª´ master key b·∫±ng Key Schedule
```

**V√≠ D·ª•:**
```
State (4 bytes): [00 01 02 03]
RoundKey:        [0F 0E 0D 0C]
Output:          [0F 0F 0F 0F]
```

### 6.3 C·∫•u Tr√∫c AES ƒê·∫ßy ƒê·ªß

####  **A. T·ªïng Quan**

```
Plaintext (128-bit)
    ‚Üì
[Initial AddRoundKey]
    ‚Üì
[10/12/14 v√≤ng]:
  1. SubBytes (S-box)
  2. ShiftRows (Permutation)
  3. MixColumns (Linear mixing) - B·ªè qua ·ªü v√≤ng cu·ªëi
  4. AddRoundKey (XOR kh√≥a)
    ‚Üì
Ciphertext (128-bit)
```

####  **B. S·ªë V√≤ng**

| K√≠ch Th∆∞·ªõc Kh√≥a | V√≤ng |
|-----------------|------|
| 128-bit | 10 |
| 192-bit | 12 |
| 256-bit | 14 |

### 6.4 Key Schedule AES

####  **A. Sinh Kh√≥a V√≤ng**

```
T·ª´ master key (128/192/256-bit), sinh c√°c kh√≥a v√≤ng cho m·ªói v√≤ng

B∆∞·ªõc:
1. Chia key th√†nh t·ª´ 32-bit (4 bytes)
2. Cho m·ªói t·ª´ m·ªõi:
   - Rotate-word: [a0, a1, a2, a3] ‚Üí [a1, a2, a3, a0]
   - SubWord: √Åp d·ª•ng S-box tr√™n m·ªói byte
   - XOR v·ªõi Rcon: [0x01, 0x00, 0x00, 0x00] √ó x^round (trong GF(2^8))
   - XOR v·ªõi t·ª´ tr∆∞·ªõc
```

####  **B. V√≠ D·ª•**

```
Master Key (128-bit): 2B7E151628AED2A6ABF7158809CF4F3C

Word0 = 2B7E1516
Word1 = 28AED2A6
Word2 = ABCF7158
Word3 = 809CF4F3

Sinh Word4:
  TempWord = RotWord(Word3) = 9CF4F380
  TempWord = SubWord(9CF4F380) = 8A84EB01
  TempWord = 8A84EB01 ‚äï Rcon[1] = 8A84EB01 ‚äï 01000000 = 8B84EB01
  Word4 = Word0 ‚äï TempWord = 2B7E1516 ‚äï 8B84EB01 = A0FA1654
```

### K·∫øt Qu·∫£ Ki·ªÉm Th·ª≠
**K·∫øt qu·∫£ th·ª±c nghi·ªám:**
![K·∫øt qu·∫£ 20](/home/lenovo/cryptography_project/results/test7-aes1.png)
![K·∫øt qu·∫£ 21](/home/lenovo/cryptography_project/results/test7-aes2.png)

### 6.5 T·∫•n C√¥ng AES

####  **1. Brute Force Kh√≥a**

```
AES-128: 2^128 kh√≥a ‚Üí Kh√¥ng kh·∫£ thi
AES-256: 2^256 kh√≥a ‚Üí c√†ng kh√¥ng kh·∫£ thi

T√≠nh to√°n:
- Th·ª≠ 10^18 kh√≥a/gi√¢y (GPU hi·ªán ƒë·∫°i)
- AES-128: 2^128 / 10^18 ‚âà 3.4 √ó 10^20 nƒÉm
- AES-256: ~5 √ó 10^60 nƒÉm
```

####  **2. Side-Channel Attacks**

```
- Timing attack: Ph√¢n t√≠ch th·ªùi gian th·ª±c thi
- Power analysis: Ph√¢n t√≠ch ti√™u th·ª• nƒÉng l∆∞·ª£ng
- Cache timing: Ph√¢n t√≠ch cache hits/misses
- Ph√≤ng ch·ªëng: Constant-time implementation
```

####  **3. Known-Plaintext Attack (KPA)**

```
N·∫øu bi·∫øt nhi·ªÅu (plaintext, ciphertext) pairs:
- ƒê·ªëi v·ªõi AES: V·∫´n c·∫ßn 2^128 ph√©p t√≠nh
- K·ªπ thu·∫≠t linear/differential cryptanalysis y·∫øu h∆°n
```

####  *4. Padding Oracle Attack**

```
N·∫øu server ti·∫øt l·ªô th√¥ng tin padding:
- C√≥ th·ªÉ decrypt ciphertext t·ª´ng byte
- Ph√≤ng ch·ªëng: Authenticated encryption (AES-GCM)
```

### 6.6 C·∫•u Tr√∫c Ho·∫°t ƒê·ªông Chi Ti·∫øt

####  **A. M·ªôt V√≤ng AES**

```
State input (4√ó4 bytes):
[00 04 08 0C]
[01 05 09 0D]
[02 06 0A 0E]
[03 07 0B 0F]

1. SubBytes (√°p d·ª•ng S-box tr√™n m·ªói byte):
[63 C0 A5 3E]
[4D 7E C4 EF]
[27 F5 1E 86]
[5F 47 AC FE]

2. ShiftRows (d·ªãch t·ª´ng h√†ng):
[63 C0 A5 3E]
[7E C4 EF 4D]
[1E 86 27 F5]
[FE 5F 47 AC]

3. MixColumns (tr·ªôn c·ªôt):
[47 75 40 F1]
[62 5D E8 A7]
[2F B8 61 1E]
[4A 1E 8D 77]

4. AddRoundKey (XOR kh√≥a v√≤ng):
[4A 7C 5E 3C]
[3B 19 2F 98]
[52 7D C1 43]
[15 23 8E 4E]
```

### K·∫øt Lu·∫≠n

**AES:**
- ‚úì Kh√≥a l·ªõn (128/192/256-bit) ‚Üí An to√†n
- ‚úì Kh·ªëi c·ªë ƒë·ªãnh 128-bit ‚Üí T·ªëi ∆∞u
- ‚úì V√≤ng √≠t (10-14) ‚Üí Nhanh
- ‚úì C·∫•u tr√∫c SPN ‚Üí D·ªÖ ph√¢n t√≠ch, kh√≥ ph√° v·ª°
- ‚úì Ti√™u chu·∫©n to√†n c·∫ßu ‚Üí ƒê∆∞·ª£c tin t∆∞·ªüng

**Khuy√™n d√πng:**
- **Hi·ªán nay:** AES-128 (ƒë·ªß an to√†n)
- **D√†i h·∫°n:** AES-256 (an to√†n h∆°n)
- **M·ª•c ƒë√≠ch ƒë·∫∑c bi·ªát:** AES-GCM (authenticated encryption)

**File code:** `Chuong6_MaAES/AES.py`

---

## CH∆Ø∆†NG 7: M√É RSA (RIVEST-SHAMIR-ADLEMAN)

### Gi·ªõi Thi·ªáu

RSA (1977) l√† h·ªá m√£ c√¥ng khai d√πng cho:
- **M√£ h√≥a b·∫•t ƒë·ªëi x·ª©ng:** Kh√≥a c√¥ng khai m√£ h√≥a, kh√≥a ri√™ng gi·∫£i m√£
- **K√Ω s·ªë (Digital Signature):** K√Ω v·ªõi kh√≥a ri√™ng, x√°c minh v·ªõi kh√≥a c√¥ng khai
- **Trao ƒë·ªïi kh√≥a:** M√£ h√≥a kh√≥a ƒë·ªëi x·ª©ng b·∫±ng RSA

ƒê·ªô an to√†n d·ª±a tr√™n: **Kh√≥ ph√¢n t√≠ch s·ªë l·ªõn (Factorization Problem)**

### 7.1 Sinh Kh√≥a RSA

#### **A. B∆∞·ªõc 1: Ch·ªçn Hai S·ªë Nguy√™n T·ªë p, q**

**Y√™u C·∫ßu:**
```
- p, q l√† s·ªë nguy√™n t·ªë l·ªõn (1024+ bits cho RSA-2048)
- p ‚â† q
- |p - q| kh√¥ng qu√° g·∫ßn (ch·ªëng Fermat's factorization)
- (p-1) v√† (q-1) kh√¥ng c√≥ nh√¢n t·ª≠ nh·ªè (ch·ªëng P-1 attack)
- p, q ƒë·ªôc l·∫≠p v√† ng·∫´u nhi√™n
```

**V√≠ D·ª• (S·ªë Nh·ªè):**
```
p = 61
q = 53

Ki·ªÉm tra:
- C·∫£ 61 v√† 53 ƒë·ªÅu l√† s·ªë nguy√™n t·ªë ‚úì
- |61 - 53| = 8 (kh√¥ng qu√° g·∫ßn) ‚úì
- p-1 = 60 = 2^2 √ó 3 √ó 5
- q-1 = 52 = 2^2 √ó 13
```

#### **B. B∆∞·ªõc 2: T√≠nh n v√† œÜ(n)**

**C√¥ng Th·ª©c:**
```
n = p √ó q
œÜ(n) = (p-1) √ó (q-1)

(œÜ(n) l√† h√†m Euler, s·ªë nguy√™n nh·ªè h∆°n n v√† nguy√™n t·ªë c√πng n)
```

**V√≠ D·ª•:**
```
n = 61 √ó 53 = 3233
œÜ(n) = 60 √ó 52 = 3120
```

#### **C. B∆∞·ªõc 3: Ch·ªçn Exponent C√¥ng Khai e**

**Y√™u C·∫ßu:**
```
- 1 < e < œÜ(n)
- gcd(e, œÜ(n)) = 1  (e nguy√™n t·ªë c√πng œÜ(n))
```

**Th∆∞·ªùng D√πng:**
```
e = 65537 (0x10001) = 2^16 + 1

L√Ω do:
- S·ªë nguy√™n t·ªë Fermat
- C√≥ √≠t bit = 1 ‚Üí Lu·ªπ th·ª´a nhanh (16 bit shift + c·ªông)
- C√¥ng khai ƒë∆∞·ª£c bi·∫øt ƒë·∫øn (kh√¥ng g√¢y l·ªô th√¥ng tin)
- gcd(65537, œÜ(n)) = 1 v·ªõi h·∫ßu h·∫øt n
```

**V√≠ D·ª•:**
```
Th·ª≠ e = 17:
- gcd(17, 3120) = 1 ‚úì
- 1 < 17 < 3120 ‚úì
‚Üí e = 17 h·ª£p l·ªá!
```

#### **D. B∆∞·ªõc 4: T√≠nh Private Exponent d**

**C√¥ng Th·ª©c:**
```
T√¨m d sao cho: e √ó d ‚â° 1 (mod œÜ(n))

Ph∆∞∆°ng ph√°p: Extended Euclidean Algorithm
```

**Chi Ti·∫øt T√≠nh To√°n:**
```
Extended_GCD(e=17, œÜ(n)=3120):

17 √ó d ‚â° 1 (mod 3120)
17 √ó d = 1 + k √ó 3120

D√πng Extended GCD:
gcd(17, 3120) = gcd(17, 3120 mod 17) = gcd(17, 6)
             = gcd(6, 17 mod 6) = gcd(6, 5)
             = gcd(5, 1) = 1

Backtracking:
1 = 6 - 1√ó5
  = 6 - 1√ó(17 - 2√ó6) = 3√ó6 - 17
  = 3√ó(3120 - 183√ó17) - 17 = 3√ó3120 - 549√ó17 - 17 = 3√ó3120 - 550√ó17

V·∫≠y: -550√ó17 ‚â° 1 (mod 3120)
     (-550 mod 3120) √ó 17 ‚â° 1 (mod 3120)
     (3120 - 550) √ó 17 ‚â° 1 (mod 3120)
     2570 √ó 17 ‚â° 1 (mod 3120)
     
Ho·∫∑c: d = 2753 (th∆∞·ªùng ƒë∆∞·ª£c t√≠nh ch√≠nh x√°c h∆°n)

Ki·ªÉm tra: 17 √ó 2753 = 46801 = 15 √ó 3120 + 1 ‚úì
```

#### **E. K·∫øt Qu·∫£ Sinh Kh√≥a**

```
Public Key (ƒë·ªÉ chia s·∫ª):
(e, n) = (17, 3233)

Private Key (gi·ªØ b√≠ m·∫≠t):
(d, n) = (2753, 3233)

Ho·∫∑c: (d, p, q) = (2753, 61, 53) - t·ªëi ∆∞u h√≥a cho CRT
```

### 7.2 RSA M√£ H√≥a / Gi·∫£i M√£

#### **A. M√£ H√≥a**

**C√¥ng Th·ª©c:**
```
Ciphertext C ‚â° M^e (mod n)

Trong ƒë√≥:
- M: Plaintext (0 < M < n)
- e: Public exponent
- n: Modulus
```

**V√≠ D·ª• Chi Ti·∫øt:**
```
Plaintext:  M = 65
Public Key: (e=17, n=3233)

T√≠nh C = 65^17 mod 3233:

B·∫±ng Square-and-Multiply (nhanh):
65^17 = 65^16 √ó 65^1

65^1  = 65
65^2  = 4225 ‚â° 1025 (mod 3233)
65^4  ‚â° 1025^2 ‚â° 1050625 ‚â° 915 (mod 3233)
65^8  ‚â° 915^2 ‚â° 837225 ‚â° 2045 (mod 3233)
65^16 ‚â° 2045^2 ‚â° 4182025 ‚â° 841 (mod 3233)

65^17 = 65^16 √ó 65^1 ‚â° 841 √ó 65 ‚â° 54665 ‚â° 2790 (mod 3233)

Ciphertext: C = 2790
```

#### **B. Gi·∫£i M√£**

**C√¥ng Th·ª©c:**
```
Plaintext M ‚â° C^d (mod n)

Trong ƒë√≥:
- C: Ciphertext
- d: Private exponent
- n: Modulus
```

**V√≠ D·ª• Chi Ti·∫øt:**
```
Ciphertext: C = 2790
Private Key: (d=2753, n=3233)

T√≠nh M = 2790^2753 mod 3233:

B·∫±ng Square-and-Multiply (b·ªè qua chi ti·∫øt):
2790^2753 ‚â° 65 (mod 3233)

Plaintext: M = 65 ‚úì
```

#### **C. T·∫°i Sao N√≥ Ho·∫°t ƒê·ªông?**

**Ch·ª©ng Minh To√°n H·ªçc:**
```
M ‚â° C^d ‚â° (M^e)^d ‚â° M^(ed) (mod n)

V√¨ e √ó d ‚â° 1 (mod œÜ(n)):
  e √ó d = 1 + k√óœÜ(n) v·ªõi k ‚â• 1

Theo ƒê·ªãnh L√Ω Euler:
  N·∫øu gcd(M, n) = 1: M^œÜ(n) ‚â° 1 (mod n)

V·∫≠y:
  M^(ed) = M^(1 + k√óœÜ(n)) = M √ó (M^œÜ(n))^k ‚â° M √ó 1^k ‚â° M (mod n)
  
‚Üí Gi·∫£i m√£ kh√¥i ph·ª•c plaintext g·ªëc!
```

### 7.3 RSA Digital Signature

#### **A. K√Ω S·ªë**

**C√¥ng Th·ª©c:**
```
Signature S ‚â° H(M)^d (mod n)

Trong ƒë√≥:
- M: Message c·∫ßn k√Ω
- H(M): Hash c·ªßa message (SHA-256, v.v.)
- d: Private key exponent
- n: Modulus
```

**V√≠ D·ª•:**
```
Message: "IMPORTANT MESSAGE"

B∆∞·ªõc 1: T√≠nh hash
  H = SHA-256(M) = 0x1A2B3C4D5E6F7A8B9CDEF0... (256 bits)
  (D√πng 256 bit ƒë·∫ßu ho·∫∑c mod n)
  H ‚âà 6827 (mod n=3233, gi·∫£ ƒë·ªãnh)

B∆∞·ªõc 2: K√Ω
  S ‚â° 6827^2753 (mod 3233)
  S ‚â° 2598 (mod 3233)

Signature: S = 2598
```

#### **B. X√°c Minh Ch·ªØ K√Ω**

**C√¥ng Th·ª©c:**
```
H' ‚â° S^e (mod n)

Ki·ªÉm tra: H' = H(M)?
```

**V√≠ D·ª•:**
```
Signature: S = 2598
Public Key: (e=17, n=3233)
Message: "IMPORTANT MESSAGE"

B∆∞·ªõc 1: X√°c minh ch·ªØ k√Ω
  H' ‚â° 2598^17 (mod 3233)
  H' ‚â° 6827 (mod 3233)

B∆∞·ªõc 2: T√≠nh hash message
  H = SHA-256(M) ‚âà 6827 (mod 3233)

B∆∞·ªõc 3: So s√°nh
  H' (6827) = H (6827)? ‚úì YES!
  
‚Üí Ch·ªØ k√Ω h·ª£p l·ªá!
```

#### **C. T·∫°i Sao Digital Signature Ho·∫°t ƒê·ªông?**

```
S ‚â° H^d (mod n)
S^e ‚â° (H^d)^e ‚â° H^(de) ‚â° H (mod n)

V√¨ ch·ªâ c√≥ holder c·ªßa private key d m·ªõi c√≥ th·ªÉ t√≠nh S
‚Üí Ch·ªØ k√Ω kh√¥ng th·ªÉ gi·∫£ m·∫°o
‚Üí X√°c minh ƒë∆∞·ª£c t√≠nh to√†n v·∫πn c·ªßa message
```

### 7.4 T·∫•n C√¥ng RSA

####  **1. Brute Force (V√¥ T√≠ch)**

**Kh√¥ng Kh·∫£ Thi:**
```
RSA-2048: Th·ª≠ t·∫•t c·∫£ 2^2048 kh√≥a
‚Üí 2^2048 ph√©p t√≠nh ‚âà 10^617 ph√©p t√≠nh
‚Üí Ngay c·∫£ quantum computer c≈©ng kh√¥ng th·ªÉ trong th·ªùi gian h·ª£p l√Ω

Th·ªùi gian: ‚àû (tr√™n th·ª±c t·∫ø)
```

####  **2. Factorization (D·ª±a Tr√™n n)**

**Nguy√™n L√Ω:**
```
N·∫øu bi·∫øt p v√† q:
- n = p √ó q ‚Üí ƒë√£ c√≥ n (c√¥ng khai)
- œÜ(n) = (p-1)(q-1) ‚Üí t√≠nh ƒë∆∞·ª£c
- d = e^(-1) mod œÜ(n) ‚Üí crack!

‚Üí B·ªô kh√≥a b·ªã ph√° v·ª° ho√†n to√†n
```

**C√°c Ph∆∞∆°ng Ph√°p Factorization:**

```
1. Trial Division: O(‚àön)
   - Chia th·ª≠ n cho c√°c s·ªë nguy√™n t·ªë
   - Kh√¥ng kh·∫£ thi cho n l·ªõn

2. Fermat's Method: O(‚àön), hi·ªáu qu·∫£ n·∫øu (p-q) nh·ªè
   - T√¨m: n = a¬≤ - b¬≤ = (a+b)(a-b)
   - N·∫øu p, q g·∫ßn nhau ‚Üí a, b g·∫ßn nhau ‚Üí nhanh

3. Pollard's rho: O(n^(1/4))
   - Ph∆∞∆°ng ph√°p x√°c su·∫•t
   - Hi·ªáu qu·∫£ h∆°n trial division

4. General Number Field Sieve (GNFS): 
   O(exp(1.9(log n)^(1/3)(log log n)^(2/3)))
   - Ph∆∞∆°ng ph√°p nhanh nh·∫•t hi·ªán bi·∫øt
   - Nh∆∞ng v·∫´n r·∫•t ch·∫≠m cho RSA-2048
```

**T√¨nh H√¨nh Th·ª±c T·∫ø:**
```
RSA-200 (200 digits): 2005 - m·∫•t 18 th√°ng (grid computing 70 nƒÉm m√°y)
RSA-232 (232 digits): 2020 - m·∫•t 1000 CPU-years
RSA-768 (232 digits): 2009 - m·∫•t nhi·ªÅu nƒÉm
RSA-2048 (617 digits): Ch∆∞a ai factorize c√¥ng khai (2024)

∆Ø·ªõc t√≠nh:
RSA-2048 v·ªõi GNFS: ~10^22 nƒÉm CPU-time (kh√¥ng kh·∫£ thi)
RSA-4096: ~10^51 nƒÉm CPU-time (v√¥ c√πng kh√¥ng kh·∫£ thi)
```

####  **3. Small Public Exponent Attack (e=3)**

**Nguy Hi·ªÉm:**
```
N·∫øu e nh·ªè (e=3), c√≥ th·ªÉ recover M m√† kh√¥ng c·∫ßn d:

N·∫øu M < n^(1/3):
- C = M^3 kh√¥ng b·ªã modulo (M^3 < n)
- C = M^3 ‚Üí M = ‚àõC (t√≠nh cƒÉn b·∫≠c 3 b√¨nh th∆∞·ªùng)

V√≠ d·ª•:
n = 3233, e = 3
M = 10 < 3233^(1/3) ‚âà 14.78? Kh√¥ng, 10 < 14
M^3 = 1000 < 3233? Yes!
C = 1000 ‚Üí M = ‚àõ1000 = 10 (kh√¥ng modulo!)
```

**Ph√≤ng Ch·ªëng:**
```
1. D√πng e = 65537 (l·ªõn h∆°n)
2. Th√™m padding (OAEP) tr∆∞·ªõc khi m√£ h√≥a
   - L√†m cho M > n^(1/3)
   - Th√™m t√≠nh ng·∫´u nhi√™n
```

####  **4. Small Private Exponent Attack (Wiener's Attack)**

**Nguy Hi·ªÉm:**
```
N·∫øu d < n^(1/4):
- C√≥ th·ªÉ recover d t·ª´ (e, n)
- D·ª±a tr√™n continued fractions
- M·∫•t ~log(n) ph√©p t√≠nh

V√≠ d·ª•:
n = 3233 ‚âà 4 (mod 10000)
n^(1/4) ‚âà 7.57

N·∫øu d < 7, Wiener's attack ho·∫°t ƒë·ªông
```

**Ph√≤ng Ch·ªëng:**
```
D√πng d ƒë·ªß l·ªõn:
- d > n^(1/4) (t·ªëi thi·ªÉu)
- Ho·∫∑c s·ª≠ d·ª•ng CRT (Chinese Remainder Theorem) 
  ƒë·ªÉ t·ªëi ∆∞u h√≥a gi·∫£i m√£ m√† kh√¥ng gi·∫£m d
```

####  **5. Common Modulus Attack**

**Nguy Hi·ªÉm:**
```
N·∫øu 2 ng∆∞·ªùi d√πng c√πng n nh∆∞ng e‚ÇÅ ‚â† e‚ÇÇ:
- C‚ÇÅ = M^e‚ÇÅ mod n
- C‚ÇÇ = M^e‚ÇÇ mod n
- C√≥ th·ªÉ recover M t·ª´ C‚ÇÅ, C‚ÇÇ

L√Ω do:
- N·∫øu gcd(e‚ÇÅ, e‚ÇÇ) = 1, c√≥ a, b sao cho:
  a√óe‚ÇÅ + b√óe‚ÇÇ = 1
- C‚ÇÅ^a √ó C‚ÇÇ^b = M^(a√óe‚ÇÅ + b√óe‚ÇÇ) = M^1 = M
```

**Ph√≤ng Ch·ªëng:**
```
M·ªói ng∆∞·ªùi d√πng c√≥ n, p, q ri√™ng
Kh√¥ng chia s·∫ª modulus!
```

---

###  K·∫øt Qu·∫£ Ki·ªÉm Th·ª≠
**K·∫øt qu·∫£ th·ª±c nghi·ªám:**
![K·∫øt qu·∫£ 22](/home/lenovo/cryptography_project/results/test8-rsa1.png)
![K·∫øt qu·∫£ 23](/home/lenovo/cryptography_project/results/test8-rsa2.png)

### K·∫øt Lu·∫≠n

**RSA:**
- ‚úì M√£ h√≥a b·∫•t ƒë·ªëi x·ª©ng
- ‚úì K√Ω s·ªë (authentication)
- ‚úì Trao ƒë·ªïi kh√≥a
- ‚úì An to√†n d·ª±a tr√™n factorization

**Khuy√™n d√πng:**
- **Hi·ªán nay:** RSA-2048 (ƒë·ªß an to√†n)
- **D√†i h·∫°n:** RSA-4096 (an to√†n h∆°n)
- **Thay th·∫ø:** ECC (Elliptic Curve Cryptography) - nhanh h∆°n, nh·ªè g·ªçn h∆°n

**File code:** `Chuong7_MaRSA/RSA.py`

---
## CH∆Ø∆†NG 8: H√ÄM BƒÇM (CRYPTOGRAPHIC HASH FUNCTIONS)

### Gi·ªõi Thi·ªáu

H√†m bƒÉm m·∫≠t m√£ l√† h√†m m·ªôt chi·ªÅu chuy√™n d·ª•ng cho:
- **X√°c minh to√†n v·∫πn:** Ph√°t hi·ªán n·∫øu d·ªØ li·ªáu b·ªã thay ƒë·ªïi
- **Ch·ªØ k√Ω s·ªë:** Hash message tr∆∞·ªõc khi k√Ω
- **M·∫≠t kh·∫©u:** L∆∞u hash password thay v√¨ plaintext
- **Proof-of-Work:** Bitcoin, blockchain


### 8.1 ƒê·ªãnh Nghƒ©a H√†m BƒÉm M·∫≠t M√£
 **H√†m BƒÉm h: {0,1}* ‚Üí {0,1}^n**

**Ba T√≠nh Ch·∫•t C·∫ßn Thi·∫øt:**

####  **1. Preimage Resistance (One-way)**

**ƒê·ªãnh Nghƒ©a:**
```
Cho y = h(x), kh√≥ t√¨m x sao cho h(x) = y

ƒê·ªô kh√≥: O(2^n)
```

**V√≠ D·ª•:**
```
SHA-256: n = 256 bits
ƒê·ªô kh√≥: 2^256 ‚âà 1.16 √ó 10^77 ph√©p t√≠nh

Th·ª±c t·∫ø:
- Si√™u m√°y t√≠nh: 10^18 ph√©p/gi√¢y
- C·∫ßn: 10^77 / 10^18 = 10^59 gi√¢y ‚âà 10^51 nƒÉm!
- NƒÉng l∆∞·ª£ng c·∫ßn: V√¥ c√πng l·ªõn
```

**·ª®ng D·ª•ng:**
```
L∆∞u tr·ªØ m·∫≠t kh·∫©u:
- Database l∆∞u h(password) thay v√¨ plaintext
- Ngay c·∫£ n·∫øu DB b·ªã leak, attacker kh√¥ng th·ªÉ reverse
```

####  **2. Second Preimage Resistance**

**ƒê·ªãnh Nghƒ©a:**
```
Cho x, kh√≥ t√¨m x' ‚â† x sao cho h(x) = h(x')

ƒê·ªô kh√≥: O(2^n) - t∆∞∆°ng t·ª± Preimage Resistance
```

**·ª®ng D·ª•ng:**
```
Ch·ªØ k√Ω s·ªë:
- ƒê·ªÉ gi·∫£ m·∫°o ch·ªØ k√Ω, attacker c·∫ßn t√¨m x' c√≥ hash = h(x)
- V·ªõi Preimage Resistance, ƒëi·ªÅu n√†y kh√¥ng kh·∫£ thi
```

####  **3. Collision Resistance**

**ƒê·ªãnh Nghƒ©a:**
```
Kh√≥ t√¨m x ‚â† y sao cho h(x) = h(y)

ƒê·ªô kh√≥: O(2^(n/2)) - Birthday attack!
```

**T·∫°i Sao Birthday Paradox?**
```
T·∫≠p h·ª£p n-bit c√≥ 2^n gi√° tr·ªã
Sau ‚àö(2^n) = 2^(n/2) m·∫´u, x√°c su·∫•t collision > 50%

V√≠ d·ª•: SHA-256
- 2^256 gi√° tr·ªã c√≥ th·ªÉ
- Sau 2^128 ‚âà 3.4 √ó 10^38 m·∫´u, x√°c su·∫•t collision > 50%

Th·ª±c t·∫ø:
- Si√™u m√°y t√≠nh: 10^18 ph√©p/gi√¢y
- C·∫ßn: 3.4 √ó 10^38 / 10^18 ‚âà 3.4 √ó 10^20 gi√¢y ‚âà 10^12 nƒÉm
- V·∫´n r·∫•t kh√¥ng kh·∫£ thi!

So s√°nh:
- MD5 (128-bit): Collision trong v√†i gi√¢y (l·ªói th·ªùi!)
- SHA-1 (160-bit): Collision trong 2^61 (kinh t·∫ø h∆°n)
- SHA-256 (256-bit): Collision trong 2^128 (v√¥ c√πng an to√†n)
```

### 8.2 Merkle-Damg√•rd Construction

####  **A. C·∫•u Tr√∫c Chu·∫©n**

```
Message M
    ‚Üì
[Padding]
    ‚Üì
[Split th√†nh kh·ªëi k bytes]
    ‚Üì
[IV - Initialization Vector]
    ‚Üì
[For each block B·µ¢]:
  H ‚Üê f(H, B·µ¢)  [Compression function]
    ‚Üì
[Output: H]
```

####  **B. Padding Chi Ti·∫øt**

**V√≠ D·ª•: M = "ABC" (3 bytes)**

```
B∆∞·ªõc 1: Th√™m bit '1'
  M = "ABC" = 0x414243
  M || 1 = 0x41424380 (th√™m byte 10000000)

B∆∞·ªõc 2: Th√™m bits '0' ƒë·ªÉ ƒë·∫°t length ‚â° -64 (mod 512)
  Hi·ªán t·∫°i: 4 bytes = 32 bits
  C·∫ßn: 448 bits (mod 512) = (448 - 32) / 8 = 52 bytes
  Th√™m 52 bytes c·ªßa 0x00

B∆∞·ªõc 3: Th√™m ƒë·ªô d√†i (64-bit big-endian)
  ƒê·ªô d√†i M ban ƒë·∫ßu: 3 bytes = 24 bits = 0x0000000000000018
  
Result: 64 bytes = 512 bits t·ªïng c·ªông
```

####  **C. Compression Function f(H, B)**

**ƒê·∫ßu v√†o:**
- H: Hash hi·ªán t·∫°i (t·ª´ v√≤ng tr∆∞·ªõc)
- B: Kh·ªëi tin nh·∫Øn (512 bits)

**ƒê·∫ßu ra:**
- H': Hash c·∫≠p nh·∫≠t (ƒë·ªÉ d√πng v√≤ng sau)

**T√≠nh ch·∫•t:**
```
N·∫øu f l√† collision-resistant
‚Üí To√†n b·ªô Merkle-Damg√•rd construction c≈©ng collision-resistant

ƒê·ªãnh l√Ω Merkle: "Merkle Construct Theorem"
```

---

### 8.3 SHA-1 vs SHA-256 vs SHA-512

####  **A. So S√°nh**

| Ti√™u ch√≠ | SHA-1 | SHA-256 | SHA-512 |
|----------|-------|---------|---------|
| **Output** | 160-bit | 256-bit | 512-bit |
| **Block** | 512-bit | 512-bit | 1024-bit |
| **Word** | 32-bit | 32-bit | 64-bit |
| **V√≤ng** | 80 | 64 | 80 |
| **Status** | ‚úó L·ªói th·ªùi | ‚úì Safe | ‚úì‚úì Very Safe |

####  **B. SHA-1 (L·ªói Th·ªùi)**

**Collision Found (2017):**
```
Google SHAttered attack - t√¨m 2 PDF kh√°c nhau c√≥ SHA-1 = nhau

Effort: 2^63 (thay v√¨ 2^80 k·ª≥ v·ªçng) - 9 t·ª∑ t·ª∑ hash

Timeline:
- 2005: L√Ω thuy·∫øt collision O(2^52)
- 2017: SHAttered attack th·ª±c t·∫ø
- 2024: Kh√¥ng n√™n d√πng SHA-1
```

####  **C. SHA-256 (Hi·ªán Nay)**

**C√¥ng Th·ª©c:**
```
1. Padding: Message || 1 || 0...0 || length
   (length l√† 64-bit big-endian)

2. Parse th√†nh 512-bit blocks

3. 8 working variables (a-h): m·ªói 32-bit
   IV (Initialization Vector): 8 gi√° tr·ªã 32-bit chu·∫©n
   
4. For each 512-bit block:
   - Expand th√†nh 64 t·ª´ 32-bit (message schedule)
   - For round t = 0 to 63:
     T1 = h + Œ£‚ÇÅ(e) + Ch(e,f,g) + K[t] + W[t]
     T2 = Œ£‚ÇÄ(a) + Maj(a,b,c)
     h = g; g = f; f = e; e = d + T1
     d = c; c = b; b = a; a = T1 + T2
   - Update working variables

5. K·∫øt h·ª£p v·ªõi IV ban ƒë·∫ßu

Output: 256 bits (32 bytes)
```

**H√†m C∆° B·∫£n:**
```
Ch(x, y, z) = (x ‚àß y) ‚äï (¬¨x ‚àß z)  [Conditional]
Maj(x, y, z) = (x ‚àß y) ‚äï (x ‚àß z) ‚äï (y ‚àß z)  [Majority]
Œ£‚ÇÄ(x) = ror(x, 2) ‚äï ror(x, 13) ‚äï ror(x, 22)
Œ£‚ÇÅ(x) = ror(x, 6) ‚äï ror(x, 11) ‚äï ror(x, 25)
œÉ‚ÇÄ(x) = ror(x, 7) ‚äï ror(x, 18) ‚äï shr(x, 3)
œÉ‚ÇÅ(x) = ror(x, 17) ‚äï ror(x, 19) ‚äï shr(x, 10)
```

####  **D. SHA-512 (An To√†n Cao)**

**Kh√°c SHA-256:**
```
- Word: 64-bit (thay v√¨ 32-bit)
- Block: 1024-bit (thay v√¨ 512-bit)
- V√≤ng: 80 (thay v√¨ 64)
- Output: 512-bit (thay v√¨ 256-bit)
- Constants K[t]: 80 gi√° tr·ªã 64-bit
```

**∆Øu ƒêi·ªÉm:**
```
- Output l·ªõn (512-bit) ‚Üí Birthday attack cost 2^256
- T·ª´ 64-bit ‚Üí T√≠nh to√°n l·∫° tr√™n 64-bit CPU
- M·∫°nh h∆°n SHA-256 ƒë·ªÉ ch·ªëng future attacks
```

### 8.4 ·ª®ng D·ª•ng H√†m BƒÉm

####  **A. X√°c Minh To√†n V·∫πn**

```
G·ª≠i file + hash:
1. T·∫°o: h = SHA-256(file)
2. G·ª≠i: file + h

Nh·∫≠n:
1. T√≠nh: h' = SHA-256(file nh·∫≠n)
2. Ki·ªÉm: h' = h?
   - N·∫øu c√≥: file nguy√™n v·∫πn ‚úì
   - N·∫øu kh√¥ng: file b·ªã thay ƒë·ªïi ‚úó
```

####  **B. Ch·ªØ K√Ω S·ªë**

```
K√Ω:
1. h = SHA-256(message)
2. signature = RSA_sign(h, private_key)

X√°c minh:
1. h' = SHA-256(message)
2. Ki·ªÉm: RSA_verify(signature, h', public_key)?
   - RSA s·∫Ω t√≠nh h'' = RSA_decrypt(signature)
   - So s√°nh: h' = h''?
```

####  **C. L∆∞u Tr·ªØ M·∫≠t Kh·∫©u**

```
ƒêƒÉng k√Ω:
1. Ng∆∞·ªùi d√πng nh·∫≠p: password
2. L∆∞u: h = SHA-256(password + salt)  (v·ªõi salt ng·∫´u nhi√™n)

ƒêƒÉng nh·∫≠p:
1. Ng∆∞·ªùi d√πng nh·∫≠p: password_input
2. T√≠nh: h' = SHA-256(password_input + salt)
3. Ki·ªÉm: h' = h (t·ª´ database)?
   - N·∫øu c√≥: ƒêƒÉng nh·∫≠p th√†nh c√¥ng ‚úì
   - N·∫øu kh√¥ng: Sai m·∫≠t kh·∫©u ‚úó

L·ª£i √≠ch:
- Server kh√¥ng l∆∞u plaintext password
- N·∫øu DB leak: attacker kh√¥ng th·ªÉ reverse SHA-256
- Salt ng·∫´u nhi√™n ch·ªëng rainbow table attack
```

####  **D. Blockchain / Bitcoin**

```
Proof-of-Work:
1. Block = [data, nonce, prev_hash]
2. T√¨m nonce sao cho: SHA-256(Block) < target
   - Ph·∫£i try nhi·ªÅu nonce
   - Miner n√†o t√¨m ƒë∆∞·ª£c tr∆∞·ªõc ‚Üí nh·∫≠n reward

Hash chain:
1. Block 1: hash‚ÇÅ = SHA-256(Block1)
2. Block 2: hash‚ÇÇ = SHA-256(Block2 || hash‚ÇÅ)
3. Block 3: hash‚ÇÉ = SHA-256(Block3 || hash‚ÇÇ)
4. ...

T√≠nh ch·∫•t:
- N·∫øu thay ƒë·ªïi Block c≈© ‚Üí hash c≈© thay ƒë·ªïi ‚Üí hash ti·∫øp theo thay ƒë·ªïi ‚Üí chu·ªói ph√° v·ª°
- ƒê·ªÉ gi·∫£ m·∫°o, ph·∫£i t√≠nh l·∫°i t·∫•t c·∫£ block sau ‚Üí r·∫•t m·∫Øc chi ph√≠
```

### 8.5 T·∫•n C√¥ng H√†m BƒÉm

####  **1. Brute Force Preimage**

```
Cho y = h(x), t√¨m x:
- Th·ª≠ t·∫•t c·∫£ 2^n gi√° tr·ªã c√≥ th·ªÉ
- SHA-256: 2^256 ‚âà v√¥ c√πng kh√¥ng kh·∫£ thi
```

####  **2. Birthday Attack (Collision)**

```
Nguy√™n l√Ω:
- T·∫°o 2^(n/2) random input
- T√≠nh hash c·ªßa t·ª´ng c√°i
- T√¨m 2 c√°i c√≥ hash gi·ªëng nhau

Effort: 2^(n/2)

SHA-256:
- 2^128 ‚âà 3.4 √ó 10^38 ph√©p t√≠nh
- V·∫´n kh√¥ng kh·∫£ thi

MD5 (l·ªói th·ªùi):
- 2^64 ‚âà v√†i t·ª∑ ph√©p t√≠nh
- T√¨m collision trong v√†i gi√¢y!
```

####  **3. Length Extension Attack**

```
N·∫øu h√†m d√πng Merkle-Damg√•rd v√† ta bi·∫øt h(M):
- C√≥ th·ªÉ t√≠nh h(M || M') m√† kh√¥ng bi·∫øt M!
- B·∫±ng c√°ch m·ªü r·ªông padding

V√≠ d·ª•:
- h(password || user_data) ƒë∆∞·ª£c s·ª≠ d·ª•ng
- Attacker t√≠nh h(password || user_data || malicious)
- Gi·ªëng h·ªát nh∆∞ n·∫øu server hash(password || user_data || malicious)

Ph√≤ng ch·ªëng:
- HMAC (Hash-based Message Authentication Code)
- h(password || message) ‚Üí kh√¥ng an to√†n
- HMAC(password, message) ‚Üí an to√†n!
```

####  **4. Rainbow Table & Dictionary Attack**

```
Rainbow Table:
- T·∫°o b·∫£ng: [plaintext ‚Üí hash] cho t·∫•t c·∫£ password ph·ªï bi·∫øn
- Lookup: N·∫øu h(x) n·∫±m trong b·∫£ng ‚Üí t√¨m ƒë∆∞·ª£c x

Ph√≤ng Ch·ªëng:
- Th√™m salt: h(password + salt)
- Salt ng·∫´u nhi√™n cho m·ªói user
- V·ªõi salt, attacker ph·∫£i t√≠nh b·∫£ng ri√™ng cho m·ªói salt!
```

### K·∫øt Qu·∫£ Ki·ªÉm Th·ª≠
**K·∫øt qu·∫£ th·ª±c nghi·ªám:**
![K·∫øt qu·∫£ 22](/home/lenovo/cryptography_project/results/test8-1.png)

### 8.6 Th·ªëng K√™ Hash Security

| Hash | Output | Birthday | Status | NƒÉm |
|------|--------|----------|--------|-----|
| MD5 | 128-bit | 2^64 | ‚úó Broken | 1992 |
| SHA-1 | 160-bit | 2^80 | ‚úó L·ªói th·ªùi | 1995 |
| SHA-256 | 256-bit | 2^128 | ‚úì Safe | 2001 |
| SHA-512 | 512-bit | 2^256 | ‚úì‚úì Very Safe | 2001 |
| BLAKE2 | 256-512 | 2^128-256 | ‚úì Fast & Safe | 2012 |

### K·∫øt Lu·∫≠n

**H√†m BƒÉm M·∫≠t M√£:**
- ‚úì M·ªôt chi·ªÅu (kh√¥ng th·ªÉ reverse)
- ‚úì X√°c ƒë·ªãnh (input gi·ªëng ‚Üí output gi·ªëng)
- ‚úì T·ªëc ƒë·ªô (t√≠nh nhanh)
- ‚úì X√°c minh to√†n v·∫πn (detect thay ƒë·ªïi)
- ‚úì ·ª®ng d·ª•ng r·ªông (ch·ªØ k√Ω, m·∫≠t kh·∫©u, blockchain)

**Khuy√™n d√πng:**
- **Hi·ªán nay:** SHA-256, SHA-512 (chu·∫©n NIST)
- **Thay th·∫ø:** BLAKE2 (nhanh h∆°n, hi·ªán ƒë·∫°i h∆°n)
- **Tr√°nh:** MD5, SHA-1 (l·ªói th·ªùi, ƒë√£ b·ªã crack)

**File code:** `Chuong8_HamBam/hash_signature_keymanagement.py`
---

## B·∫¢NG SO S√ÅNH TO√ÄN DI·ªÜN C√ÅC H·ªÜ M·∫¨T

| H·ªá Th·ªëng | NƒÉm | Kh√≥a | Kh·ªëi | V√≤ng | B·∫£o M·∫≠t (2024) | Ghi ch√∫ |
|----------|-----|------|------|------|----------------|---------|
| Caesar | ~0 BC | 26 | N/A | 1 | ‚úó Trivial | Brute force d·ªÖ |
| Vigen√®re | 1553 | variable | N/A | variable | ‚úó Weak | Frequency analysis |
| DES | 1977 | 56 | 64 | 16 | ‚úó Broken | 2^56 kh√≥a |
| 3DES | 1998 | 168 | 64 | 48 | ‚ö† Legacy | 2^112 nh∆∞ng ch·∫≠m |
| AES-128 | 2001 | 128 | 128 | 10 | ‚úì Strong | Standard hi·ªán t·∫°i |
| AES-256 | 2001 | 256 | 128 | 14 | ‚úì‚úì Very Strong | D√†i h·∫°n |
| RSA-2048 | 1977 | 2048 | variable | 1 | ‚úì Safe | Ph·ª• thu·ªôc factorization |
| ECC-256 | 2000 | 256 | variable | 1 | ‚úì Strong | Nhanh h∆°n RSA |
| SHA-256 | 2001 | N/A | 512 | 64 | ‚úì Safe | Standard |
| SHA-512 | 2001 | N/A | 1024 | 80 | ‚úì‚úì Safe | M·∫°nh h∆°n SHA-256 |
| Knapsack | 1978 | variable | variable | 1 | ‚úó BROKEN | Shamir 1984 |

---

## T·ªîNG K·∫æT B·∫¢O M·∫¨T

### T·∫•n C√¥ng Ph·ªï Bi·∫øn

| T·∫•n C√¥ng | M·ª•c Ti√™u | ƒê·ªô Ph·ª©c T·∫°p | Ph√≤ng Ch·ªëng |
|----------|----------|------------|-----------|
| Brute Force | Kh√≥a | 2^k | Kh√≥a d√†i |
| Frequency Analysis | Substitution | O(n) | Vigen√®re+ |
| Meet-in-the-Middle | 2DES | 2^57 | 3DES |
| Differential Cryptanalysis | DES/AES | L√Ω thuy·∫øt | Thi·∫øt k·∫ø c·∫©n th·∫≠n |
| Linear Cryptanalysis | DES | 2^43 d·ªØ li·ªáu | Thi·∫øt k·∫ø c·∫©n th·∫≠n |
| Factorization | RSA | O(exp(...)) | p, q l·ªõn |
| Birthday Attack | Hash | 2^(n/2) | Hash d√†i |
| Side-Channel | Any | Th·ª±c t·∫ø | Constant-time code |

---

### ƒê·ªô Ph·ª©c T·∫°p T√≠nh To√°n

| Thu·∫≠t To√°n | ƒê·ªô Ph·ª©c T·∫°p | Th·ªùi Gian (V√≠ D·ª•) |
|-----------|-----------|------------------|
| GCD (Euclidean) | O(log n) | ~1 microsecond |
| Prime Check (Trial Division) | O(‚àön) | ~1 millisecond (n = 10^9) |
| Factorization (Trial Division) | O(‚àön) | ~1 second (n = 10^12) |
| Factorization (GNFS) | O(exp(1.9(log n)^(1/3))) | ~centuries (RSA-2048) |
| DES Encryption | O(1) [fixed rounds] | ~10 microseconds |
| AES Encryption | O(1) [fixed rounds] | ~20 microseconds |
| RSA Encryption (2048-bit) | O(log e) [fast exp] | ~100 microseconds |
| SHA-256 Hashing | O(n) [linear] | ~10 microseconds (512 bytes) |

---

## K·∫æT LU·∫¨N B√ÅO C√ÅO

D·ª± √°n n√†y cung c·∫•p:
‚úÖ **Ki·∫øn th·ª©c l√Ω thuy·∫øt to√†n di·ªán** t·ª´ c∆° b·∫£n ƒë·∫øn n√¢ng cao  
‚úÖ **Code tri·ªÉn khai t·ª´ng thu·∫≠t to√°n** (kh√¥ng d√πng th∆∞ vi·ªán)  
‚úÖ **·ª®ng d·ª•ng th·ª±c t·∫ø** (m√£ h√≥a, k√Ω, bƒÉm, qu·∫£n l√Ω kh√≥a)  
‚úÖ **Tham chi·∫øu chi ti·∫øt** ƒë·∫øn t√†i li·ªáu g·ªëc  
‚úÖ **Output ki·ªÉm ch·ª©ng** cho m·ªói thu·∫≠t to√°n  

---